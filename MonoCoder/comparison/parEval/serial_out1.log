{"algo": "dense_la", "spec": "00_dense_la_lu_decomp", "prompt": "/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {", "completion": "\n#include <vector>\n#include <iostream>\n\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t i = k + 1; i < N; ++i) {\n            A[i * N + k] /= A[k * N + k];\n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= A[i * N + k] * A[k * N + j];\n            }\n        }\n    }\n\n    std::cout << \"Matrix L + U: \\n\";\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            if (j < i) {\n                // Below diagonal (L)\n                std::cout << A[i * N + j] << \"\\t\";\n            } else {\n                // Above or on diagonal (U)\n                std::cout << A[i * N + j] << \"\\t\";\n            }\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nint main() {\n    std::vector<double> A = {4, 3, 6, 3}; // NxN matrix data in row-major order\n    size_t N = 2; // Size of the matrix\n\n    luFactorize(A, N);\n\n    return 0;\n}\n"}
{"algo": "dense_la", "spec": "01_dense_la_solve", "prompt": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {", "completion": "\n#include <iostream>\n#include <vector>\n\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    // Convert the row-major vector A to a 2D matrix A_matrix\n    std::vector<std::vector<double>> A_matrix(N, std::vector<double>(N));\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            A_matrix[i][j] = A[i * N + j];\n        }\n    }\n\n    // Gaussian elimination\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = i + 1; j < N; j++) {\n            double ratio = A_matrix[j][i] / A_matrix[i][i];\n            for (size_t k = 0; k < N; k++) {\n                A_matrix[j][k] -= ratio * A_matrix[i][k];\n            }\n            b[j] -= ratio * b[i];\n        }\n    }\n\n    // Back-substitution to get x\n    x.resize(N);\n    for (int i = N - 1; i >= 0; i--) {\n        x[i] = b[i];\n        for (size_t j = i + 1; j < N; j++) {\n            x[i] -= A_matrix[i][j] * x[j];\n        }\n        x[i] /= A_matrix[i][i];\n    }\n}\n\nint main() {\n    std::vector<double> A = {1, 4, 2, 1, 2, 3, 2, 1, 3};\n    std::vector<double> b = {11, 11, 13};\n    std::vector<double> x;\n\n    size_t N = 3;\n    solveLinearSystem(A, b, x, N);\n\n    for (size_t i = 0; i < N; i++) {\n        std::cout << \"x[\" << i << \"] = \" << x[i] << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "dense_la", "spec": "02_dense_la_gemm", "prompt": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {", "completion": "\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            C[i * N + j] = 0;\n            for (size_t k = 0; k < K; ++k) {\n                C[i * N + j] += A[i * K + k] * B[k * N + j];\n            }\n        }\n    }\n}\n"}
{"algo": "dense_la", "spec": "03_dense_la_axpy", "prompt": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {", "completion": "\n#include <vector>\n\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    // Check if the sizes of x and y are compatible\n    if (x.size() != y.size()) {\n        // Handle the error (e.g., throw an exception or return an error code)\n        return;\n    }\n\n    // Resize z to match the size of x and y\n    z.resize(x.size());\n\n    // Compute z = alpha*x + y\n    for (size_t i = 0; i < x.size(); ++i) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n\nint main() {\n    // Example usage\n    std::vector<double> x = {1, -5, 2, 9};\n    std::vector<double> y = {0, 4, 1, -1};\n    std::vector<double> z;\n\n    double alpha = 2;\n    axpy(alpha, x, y, z);\n\n    // Print the result\n    for (double result : z) {\n        std::cout << result << \" \";\n    }\n\n    return 0;\n}\n"}
{"algo": "dense_la", "spec": "04_dense_la_gemv", "prompt": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {", "completion": "\n#include <iostream>\n#include <vector>\n\nvoid gemv(const std::vector<double>& A, const std::vector<double>& x, std::vector<double>& y, size_t M, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        y[i] = 0;\n        for (size_t j = 0; j < N; ++j) {\n            y[i] += A[i * N + j] * x[j];\n        }\n    }\n}\n\nint main() {\n    // Example input\n    std::vector<double> A = {1, -1, 2, 0, -3, 1};\n    std::vector<double> x = {2, 1, 0};\n    std::vector<double> y(2); // Size M = 2\n\n    // Perform the matrix-vector multiplication\n    gemv(A, x, y, 2, 3);\n\n    // Display the result\n    std::cout << \"Result y = [\";\n    for (size_t i = 0; i < y.size(); ++i) {\n        std::cout << y[i] << (i < y.size() - 1 ? \", \" : \"\");\n    }\n    std::cout << \"]\" << std::endl;\n\n    return 0;\n}\n"}
{"algo": "fft", "spec": "05_fft_inverse_fft", "prompt": "/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {", "completion": "\n   #include <complex>\n   "}
{"algo": "fft", "spec": "06_fft_dft", "prompt": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {", "completion": "\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <vector>\n\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n    size_t N = x.size();\n    for (size_t k = 0; k < N; ++k) {\n        output[k] = {0.0, 0.0};\n        for (size_t n = 0; n < N; ++n) {\n            double angle = 2.0 * M_PI * k * n / N;\n            output[k] += std::polar(x[n], -angle);\n        }\n    }\n}\n\nint main() {\n    std::vector<double> input = {1, 4, 9, 16};\n    std::vector<std::complex<double>> output(input.size());\n\n    dft(input, output);\n\n    // Output the result\n    for (size_t i = 0; i < output.size(); ++i) {\n        std::cout << output[i] << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "fft", "spec": "07_fft_fft_conjugate", "prompt": "/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {", "completion": "\n#include <vector>\n#include <complex>\n#include <cmath>\n\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\n    int n = x.size();\n    \n    if (n <= 1) {\n        return;\n    }\n    \n    std::vector<std::complex<double>> even(n/2), odd(n/2);\n    \n    for (int i = 0; i < n / 2; ++i) {\n        even[i] = x[i * 2];\n        odd[i] = x[i * 2 + 1];\n    }\n    \n    fftConjugate(even);\n    fftConjugate(odd);\n    \n    for (int k = 0; k < n / 2; ++k) {\n        std::complex<double> t = std::polar(1.0, -2 * M_PI * k / n) * odd[k];\n        x[k] = even[k] + t;\n        x[k + n / 2] = even[k] - t;\n    }\n}\n"}
{"algo": "fft", "spec": "08_fft_split_fft", "prompt": "/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {", "completion": "\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    int N = x.size();\n    std::vector<std::complex<double>> X(N);\n    \n    std::copy(x.begin(), x.end(), X.begin());\n    std::fft(X.data(), N);\n    \n    r.resize(N);\n    i.resize(N);\n    \n    for (int k = 0; k < N; ++k) {\n        r[k] = X[k].real();\n        i[k] = X[k].imag();\n    }\n}\n\nint main() {\n    std::vector<std::complex<double>> x = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n    std::vector<double> r, i;\n    \n    fft(x, r, i);\n    \n    std::cout << \"Real part: \";\n    for (auto val : r) {\n        std::cout << val << \" \";\n    }\n    \n    std::cout << \"\\nImaginary part: \";\n    for (auto val : i) {\n        std::cout << val << \" \";\n    }\n    \n    return 0;\n}\n"}
{"algo": "fft", "spec": "09_fft_fft_out_of_place", "prompt": "/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {", "completion": "\n#include <vector>\n#include <complex>\n#include <fftw3.h>\n\nvoid fft(const std::vector<std::complex<double>>& x, std::vector<std::complex<double>>& output) {\n    int N = x.size();\n    output.resize(N);\n\n    fftw_complex* in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n    fftw_complex* out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n\n    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    // Copy input data to fftw_complex array\n    for (int i = 0; i < N; ++i) {\n        in[i][0] = x[i].real();\n        in[i][1] = x[i].imag();\n    }\n\n    fftw_execute(p);\n\n    // Copy FFT result to output\n    for (int i = 0; i < N; ++i) {\n        output[i] = std::complex<double>(out[i][0], out[i][1]);\n    }\n\n    fftw_destroy_plan(p);\n    fftw_free(in);\n    fftw_free(out);\n}\n"}
{"algo": "geometry", "spec": "10_geometry_convex_hull", "prompt": "struct Point {\n   double x, y;\n};\n\n/* Find the set of points that defined the smallest convex polygon that contains all the points in the vector points. Store the result in `hull`.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: [{0, 3}, {4, 4}, {3, 1}, {0, 0}]\n*/\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {", "completion": "\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0; // Collinear\n    return (val > 0) ? 1 : 2; // Clockwise or counterclockwise\n}\n"}
{"algo": "geometry", "spec": "11_geometry_convex_hull_perimeter", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the perimeter of the smallest convex polygon that contains all the points in the vector points.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: 13.4477\n*/\ndouble convexHullPerimeter(std::vector<Point> const& points) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\n// Helper function to calculate cross product\ndouble crossProduct(Point const& o, Point const& a, Point const& b) {\n    return (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);\n}\n\n// Function to compute convex hull\nstd::vector<Point> convexHull(std::vector<Point> points) {\n    int n = points.size();\n    if (n <= 3) {\n        return points;\n    }\n\n    std::sort(points.begin(), points.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    std::vector<Point> hull;\n    int k = 0;\n\n    // Lower Hull\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && crossProduct(hull[k - 2], hull[k - 1], points[i]) <= 0) {\n            hull.pop_back();\n            k--;\n        }\n        hull.push_back(points[i]);\n        k++;\n    }\n\n    // Upper Hull\n    for (int i = n - 2, t = k + 1; i >= 0; --i) {\n        while (k >= t && crossProduct(hull[k - 2], hull[k - 1], points[i]) <= 0) {\n            hull.pop_back();\n            k--;\n        }\n        hull.push_back(points[i]);\n        k++;\n    }\n\n    hull.pop_back(); // Last point is duplicated\n\n    return hull;\n}\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    std::vector<Point> convexHullPoints = convexHull(points);\n\n    double perimeter = 0;\n    for (size_t i = 0; i < convexHullPoints.size(); ++i) {\n        perimeter += distance(convexHullPoints[i], convexHullPoints[(i + 1) % convexHullPoints.size()]);\n    }\n\n    return perimeter;\n}\n"}
{"algo": "geometry", "spec": "12_geometry_smallest_triangle", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {", "completion": "\n#include <vector>\n#include <algorithm> // for std::min_element\n#include <cmath>     // for std::abs\n#include <limits>    // for std::numeric_limits\n\nstruct Point {\n    double x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n    return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points */\ndouble smallestArea(std::vector<Point> const& points) {\n    double minArea = std::numeric_limits<double>::max();\n\n    // Generate all combinations of 3 points\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            for (size_t k = j + 1; k < points.size(); ++k) {\n                double area = triangleArea(points[i], points[j], points[k]);\n                minArea = std::min(area, minArea);\n            }\n        }\n    }\n\n    return minArea;\n}\n\nint main() {\n    // Example usage\n    std::vector<Point> points = {{0, 10}, {5, 5}, {1, 0}, {-1, 1}, {-10, 0}};\n    double result = smallestArea(points);\n    return result;\n}\n"}
{"algo": "geometry", "spec": "13_geometry_closest_pair_2d", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {", "completion": "\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\ndouble closestPair(std::vector<Point> const& points) {\n    double minDistance = std::numeric_limits<double>::max();\n\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            minDistance = std::min(minDistance, distance(points[i], points[j]));\n        }\n    }\n\n    return minDistance;\n}\n"}
{"algo": "geometry", "spec": "14_geometry_closest_pair_1d", "prompt": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\ndouble distance(double x1, double x2) {\n    return std::abs(x1 - x2);\n}\n\ndouble closestPair(std::vector<double> const& x) {\n    std::vector<double> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n\n    double min_distance = std::numeric_limits<double>::max();\n\n    for (size_t i = 0; i < sorted_x.size() - 1; ++i) {\n        double curr_distance = distance(sorted_x[i], sorted_x[i + 1]);\n        min_distance = std::min(min_distance, curr_distance);\n    }\n\n    return min_distance;\n}\n\nint main() {\n    std::vector<double> x = {7, 3, 9, 12, 31, 1};\n    double result = closestPair(x);\n    return 0;\n}\n"}
{"algo": "graph", "spec": "15_graph_edge_count", "prompt": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {", "completion": "\n#include <vector>\n\nint edgeCount(std::vector<int> const& A, size_t N) {\n    int count = 0;\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (A[i * N + j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<std::vector<int>> input = {{0, 0, 0, 1}, {0, 0, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}};\n    size_t N = input.size();\n\n    std::vector<int> flattened_input;\n     for (const auto& row : input) {\n        flattened_input.insert(flattened_input.end(), row.begin(), row.end());\n    }\n\n    int result = edgeCount(flattened_input, N);\n    std::cout << \"Number of edges: \" << result << std::endl;\n\n    return 0;\n}\n"}
{"algo": "graph", "spec": "16_graph_largest_component", "prompt": "/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {", "completion": "\n#include <vector>\n#include <stack>\n#include <unordered_set>\n\nint DFS(std::vector<int> const& A, size_t N, int start, std::unordered_set<int>& visited) {\n    int count = 0;\n    \n    std::stack<int> stack;\n    stack.push(start);\n    \n    while (!stack.empty()) {\n        int current = stack.top();\n        stack.pop();\n        \n        if (visited.count(current) == 0) {\n            visited.insert(current);\n            count++;\n            \n            for (int i = 0; i < N; ++i) {\n                if (A[current * N + i] == 1 && visited.count(i) == 0) {\n                    stack.push(i);\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nint largestComponent(std::vector<int> const& A, size_t N) {\n    int maxComponentSize = 0;\n    std::unordered_set<int> visited;\n    \n    for (int i = 0; i < N; ++i) {\n        if (visited.count(i) == 0) {\n            int componentSize = DFS(A, N, i, visited);\n            if (componentSize > maxComponentSize) {\n                maxComponentSize = componentSize;\n            }\n        }\n    }\n    \n    return maxComponentSize;\n}\n"}
{"algo": "graph", "spec": "17_graph_highest_degree", "prompt": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {", "completion": "\n#include <vector>\n#include <algorithm>\n\nint maxDegree(std::vector<int> const& A, size_t N) {\n    int maxDegree = 0;\n    \n    for (size_t i = 0; i < N; ++i) {\n        int degree = 0;\n        for (size_t j = 0; j < N; ++j) {\n            if (A[i * N + j] == 1) {\n                ++degree;\n            }\n        }\n        maxDegree = std::max(maxDegree, degree);\n    }\n    \n    return maxDegree;\n}\n"}
{"algo": "graph", "spec": "18_graph_count_components", "prompt": "/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {", "completion": "\n#include <vector>\n#include <unordered_set>\n\nvoid dfs(const std::vector<int>& A, std::unordered_set<int>& visited, int current, int N) {\n    visited.insert(current);\n    for (int i = 0; i < N; ++i) {\n        if (A[current * N + i] == 1 && visited.find(i) == visited.end()) {\n            dfs(A, visited, i, N);\n        }\n    }\n}\n\nint componentCount(const std::vector<int>& A, size_t N) {\n    int count = 0;\n    std::unordered_set<int> visited;\n\n    for (int i = 0; i < N; ++i) {\n        if (visited.find(i) == visited.end()) {\n            dfs(A, visited, i, N);\n            ++count;\n        }\n    }\n\n    return count;\n}\n"}
{"algo": "graph", "spec": "19_graph_shortest_path", "prompt": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {", "completion": "\n#include <vector>\n#include <queue>\n\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n    std::vector<bool> visited(N, false);\n    std::queue<std::pair<int, int>> q; // Pair of node and distance from source\n\n    q.push({source, 0});\n    visited[source] = true;\n\n    while (!q.empty()) {\n        int node = q.front().first;\n        int dist = q.front().second;\n        q.pop();\n\n        if (node == dest) {\n            return dist;\n        }\n\n        for (int i = 0; i < N; ++i) {\n            if (A[node * N + i] && !visited[i]) {\n                q.push({i, dist + 1});\n                visited[i] = true;\n            }\n        }\n    }\n\n    return -1; // If source and destination are not connected\n}\n"}
{"algo": "histogram", "spec": "20_histogram_pixel_histogram", "prompt": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {", "completion": "\n#include <vector>\n#include <array>\n\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256>& bins) {\n    // Initialize the bins to zeros\n    bins.fill(0);\n\n    // Iterate through the image vector\n    for (int intensity : image) {\n        // Increment the count for the corresponding intensity level\n        bins[intensity]++;\n    }\n}\n"}
{"algo": "histogram", "spec": "21_histogram_bin_0-100", "prompt": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <array>\n\nvoid binsBy10Count(const std::vector<double> &x, std::array<size_t, 10> &bins) {\n    for (double value : x) {\n        size_t bin = static_cast<size_t>(value) / 10;\n        if (bin < bins.size()) {\n            ++bins[bin];\n        }\n    }\n}\n\nint main() {\n    std::vector<double> input = {7, 32, 95, 12, 39, 32, 11, 71, 70, 66};\n    std::array<size_t, 10> bins = {0};\n\n    binsBy10Count(input, bins);\n\n    for (size_t i = 0; i < bins.size(); ++i) {\n        std::cout << \"Count in bin [\" << i * 10 << \", \" << (i + 1) * 10 << \"): \" << bins[i] << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "histogram", "spec": "22_histogram_count_quadrants", "prompt": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {", "completion": "\n#include <vector>\n#include <array>\n\nstruct Point {\n    double x, y;\n};\n\nvoid countQuadrants(const std::vector<Point> &points, std::array<size_t, 4> &bins) {\n    // Initialize the bins array with zeros\n    bins.fill(0);\n\n    // Iterate over each point in the vector\n    for(const Point &point : points) {\n        if (point.x > 0 && point.y > 0) {\n            // Point in first quadrant\n            bins[0]++;\n        } else if (point.x < 0 && point.y > 0) {\n            // Point in second quadrant\n            bins[1]++;\n        } else if (point.x < 0 && point.y < 0) {\n            // Point in third quadrant\n            bins[2]++;\n        } else if (point.x > 0 && point.y < 0) {\n            // Point in fourth quadrant\n            bins[3]++;\n        }\n    }\n}\n\nint main() {\n    std::vector<Point> points = {{1.5, 0.1}, {-3, 1.1}, {5, 9}, {1.5, -1}, {3, -7}, {0.1, 2}};\n    std::array<size_t, 4> bins = {0, 0, 0, 0};\n\n    countQuadrants(points, bins);\n\n    // Display the counts in each quadrant\n    for(size_t i = 0; i < bins.size(); ++i) {\n        std::cout << \"Quadrant \" << (i+1) << \" count: \" << bins[i] << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "histogram", "spec": "23_histogram_first_letter_counts", "prompt": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <array>\n\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    for (const std::string& str : s) {\n        if (!str.empty()) {\n            char firstChar = str[0];\n            if (firstChar >= 'a' && firstChar <= 'z') {\n                bins[firstChar - 'a']++;\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> input = {\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"};\n    std::array<size_t, 26> bins = {0};\n\n    firstLetterCounts(input, bins);\n\n    // Output the result\n    std::cout << \"[\";\n    for (size_t count : bins) {\n        std::cout << count << \", \";\n    }\n    std::cout << \"]\" << std::endl;\n\n    return 0;\n}\n"}
{"algo": "histogram", "spec": "24_histogram_count_quartile", "prompt": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {", "completion": "\n#include <vector>\n#include <array>\n#include <cmath>\n\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    for (double num : x) {\n        double frac;\n        double intPart = std::modf(num, &frac);\n        \n        if (frac < 0.25) {\n            ++bins[0];\n        } else if (frac < 0.5) {\n            ++bins[1];\n        } else if (frac < 0.75) {\n            ++bins[2];\n        } else {\n            ++bins[3];\n        }\n    }\n}\n"}
{"algo": "reduce", "spec": "25_reduce_xor", "prompt": "/* Return the logical XOR reduction of the vector of bools x.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {", "completion": "\n#include <vector>\n\nbool reduceLogicalXOR(const std::vector<bool>& x) {\n    bool result = false;\n    for (bool b : x) {\n        result ^= b;\n    }\n    return result;\n}\n"}
{"algo": "reduce", "spec": "26_reduce_product_of_inverses", "prompt": "/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {", "completion": "\ndouble productWithInverses(std::vector<double> const& x) {\n    double product = 1.0;\n    for (size_t i = 0; i < x.size(); i++) {\n        if (i % 2 == 0) {\n            product *= x[i];\n        } else {\n            product /= x[i];\n        }\n    }\n    return product;\n}\n"}
{"algo": "reduce", "spec": "27_reduce_average", "prompt": "/* Return the average of the vector x.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {", "completion": "\n#include <vector>\n\ndouble average(std::vector<double> const& x) {\n    if (x.empty()) {\n        return 0.0; // Handling the case where the vector is empty\n    }\n\n    double sum = 0.0;\n    for (auto const& elem : x) {\n        sum += elem;\n    }\n\n    return sum / x.size();\n}\n"}
{"algo": "reduce", "spec": "28_reduce_smallest_odd_number", "prompt": "/* Return the value of the smallest odd number in the vector x.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {", "completion": "\n#include <vector>\n\nint smallestOdd(std::vector<int> const& x) {\n    int smallestOdd = -1; // Initialize with a value that indicates no odd number found yet\n\n    for (int num : x) {\n        if (num % 2 != 0 && (smallestOdd == -1 || num < smallestOdd)) {\n            smallestOdd = num;\n        }\n    }\n\n    return smallestOdd;\n}\n"}
{"algo": "reduce", "spec": "29_reduce_sum_of_min_of_pairs", "prompt": "/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {", "completion": "\n#include <vector>\n#include <algorithm>\n\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n    double sum = 0.0;\n    size_t size = std::min(x.size(), y.size());\n\n    for (size_t i = 0; i < size; ++i) {\n        sum += std::min(x[i], y[i]);\n    }\n\n    return sum;\n}\n"}
{"algo": "scan", "spec": "30_scan_prefix_sum", "prompt": "/* Compute the prefix sum of the vector x into output.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {", "completion": "\n#include <vector>\n\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n    if (x.empty()) {\n        return;\n    }\n\n    output.resize(x.size());\n    output[0] = x[0];\n    \n    for (size_t i = 1; i < x.size(); ++i) {\n        output[i] = output[i - 1] + x[i];\n    }\n}\n"}
{"algo": "scan", "spec": "31_scan_scan_with_min_function", "prompt": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {", "completion": "\n#include <vector>\n#include <algorithm>\n\nvoid partialMinimums(std::vector<float> &x) {\n    if (x.empty()) {\n        return; // Nothing to do for an empty vector\n    }\n\n    float min_val = x[0]; // Initialize min_val with the first element\n    for (size_t i = 0; i < x.size(); ++i) {\n        min_val = std::min(min_val, x[i]); // Update min_val with the minimum value found so far\n        x[i] = min_val; // Replace the i-th element with the minimum value found up to the i-th index\n    }\n}\n"}
{"algo": "scan", "spec": "32_scan_sum_of_prefix_sum_array", "prompt": "/* Compute the prefix sum array of the vector x and return its sum.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {", "completion": "\n#include <vector>\n\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n    double sum = 0;\n    double prefixSum = 0;\n\n    for (double num : x) {\n        prefixSum += num;\n        sum += prefixSum;\n    }\n\n    return sum;\n}\n\nint main() {\n    std::vector<double> input = {-7, 2, 1, 9, 4, 8};\n    double result = sumOfPrefixSum(input);\n    std::cout << \"Sum of Prefix Sums: \" << result << std::endl;\n\n    return 0;\n}\n"}
{"algo": "scan", "spec": "33_scan_reverse_prefix_sum", "prompt": "/* Compute the reverse prefix sum of the vector x into output.\n   Examples:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [2, 8, 14, 18, 25, 26]\n\n   input: [3, 3, 7, 1, -2]\n   output: [-2, -1, 6, 9, 12]\n*/\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {", "completion": "\n#include <vector>\n\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    if (x.empty()) {\n        output.clear();\n        return;\n    }\n\n    output.resize(x.size());\n    int sum = 0;\n    \n    for (int i = x.size() - 1; i >= 0; --i) {\n        sum += x[i];\n        output[i] = sum;\n    }\n}\n"}
{"algo": "scan", "spec": "34_scan_largest_contiguous_subarray_sum", "prompt": "/* Return the largest sum of any contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4] then [4, \u22121, 2, 1] is the contiguous\n   subarray with the largest sum of 6.\n   Example:\n\n   input: [\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4]\n   output: 6\n*/\nint maximumSubarray(std::vector<int> const& x) {", "completion": "\n#include <vector>\n#include <algorithm> // for std::max\n\nint maximumSubarray(std::vector<int> const& x) {\n    int max_sum = x[0];\n    int current_sum = x[0];\n\n    for (size_t i = 1; i < x.size(); ++i) {\n        current_sum = std::max(x[i], current_sum + x[i]);\n        max_sum = std::max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n\n// Example usage:\nint main() {\n    std::vector<int> x = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    int result = maximumSubarray(x);\n    // Output the result\n    return 0;\n}\n"}
{"algo": "search", "spec": "35_search_search_for_last_struct_by_key", "prompt": "struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {", "completion": "\n#include <vector>\n#include <string>\n\nstruct Book {\n    std::string title;\n    int pages;\n};\n\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    for (size_t i = books.size(); i > 0; --i) {\n        if (books[i - 1].pages < 100) {\n            return i - 1;\n        }\n    }\n    // If no book with pages < 100 is found, return an appropriate value (e.g., books.size()).\n    return books.size();\n}\n\nint main() {\n    std::vector<Book> books = {\n        {\"Green Eggs and Ham\", 72},\n        {\"gulliver's travels\", 362},\n        {\"Stories of Your Life\", 54},\n        {\"Hamilton\", 818}\n    };\n\n    size_t index = findLastShortBook(books);\n    if (index < books.size()) {\n        std::cout << \"Index of the last book with pages < 100: \" << index << std::endl;\n    } else {\n        std::cout << \"No book with pages < 100 found in the provided list.\" << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "search", "spec": "36_search_check_if_array_contains_value", "prompt": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {", "completion": "\n#include <vector>\n\nbool contains(std::vector<int> const& x, int target) {\n    for (int value : x) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"algo": "search", "spec": "37_search_find_the_closest_number_to_pi", "prompt": "/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {", "completion": "\n#include <vector>\n#include <cmath>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    double closestDiff = std::abs(x[0] - M_PI);\n    size_t closestIndex = 0;\n\n    for (size_t i = 1; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < closestDiff) {\n            closestDiff = diff;\n            closestIndex = i;\n        }\n    }\n\n    return closestIndex;\n}\n"}
{"algo": "search", "spec": "38_search_find_the_first_even_number", "prompt": "/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {", "completion": "\n#include <vector>\n\nsize_t findFirstEven(std::vector<int> const& x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) { // Check if current element is even\n            return i; // Return the index if found\n        }\n    }\n    return -1; // Return -1 if no even number is found\n}\n"}
{"algo": "search", "spec": "39_search_xor_contains", "prompt": "/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {", "completion": "\n#include <vector>\n#include <unordered_set>\n\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool inX = std::find(x.begin(), x.end(), val) != x.end();\n    bool inY = std::find(y.begin(), y.end(), val) != y.end();\n\n    // Return true if val is only in one of the vectors x or y\n    // Return false if it is in both or neither\n    return (inX && !inY) || (!inX && inY);\n}\n\n// Test your function with the provided examples\nint main() {\n    std::vector<int> x = {1, 8, 4, 3, 2};\n    std::vector<int> y = {3, 4, 4, 1, 1, 7};\n\n    // Test case 1\n    int val1 = 7;\n    bool result1 = xorContains(x, y, val1);\n    std::cout << \"Is \" << val1 << \" found in only one vector? \" << std::boolalpha << result1 << std::endl;\n\n    // Test case 2\n    int val2 = 1;\n    bool result2 = xorContains(x, y, val2);\n    std::cout << \"Is \" << val2 << \" found in only one vector? \" << std::boolalpha << result2 << std::endl;\n\n    return 0;\n}\n"}
{"algo": "sort", "spec": "40_sort_sort_an_array_of_complex_numbers_by_magnitude", "prompt": "/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {", "completion": "\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nbool compareMagnitude(const std::complex<double> &a, const std::complex<double> &b) {\n    return std::abs(a) < std::abs(b);\n}\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    std::sort(x.begin(), x.end(), compareMagnitude);\n}\n"}
{"algo": "sort", "spec": "41_sort_k-th_smallest_element", "prompt": "/* Find the k-th smallest element of the vector x.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {", "completion": "\n#include <vector>\n#include <algorithm>\n\nint findKthSmallest(std::vector<int> const& x, int k) {\n    std::vector<int> sortedX = x;\n    std::sort(sortedX.begin(), sortedX.end());\n\n    // Return the k-th smallest element (k-1 index in zero-based indexing)\n    return sortedX[k - 1];\n}\n\n// Example usage\n// int main() {\n//     std::vector<int> x = {1, 7, 6, 0, 2, 2, 10, 6};\n//     int k = 4;\n//     int result = findKthSmallest(x, k);\n//     // Output should be 6\n//     return 0;\n// }\n"}
{"algo": "sort", "spec": "42_sort_sorted_ranks", "prompt": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {", "completion": "\n#include <vector>\n#include <map>\n#include <algorithm>\n\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n    // Create a copy of the original vector and sort it in increasing order\n    std::vector<float> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n\n    // Initialize a map to store index of each element in the sorted vector\n    std::map<float, size_t> index_map;\n    for (size_t i = 0; i < sorted_x.size(); ++i) {\n        index_map[sorted_x[i]] = i;\n    }\n\n    // Get ranks for elements in the original vector\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks.push_back(index_map[x[i]]);\n    }\n}\n"}
{"algo": "sort", "spec": "43_sort_sort_an_array_of_structs_by_key", "prompt": "struct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {", "completion": "\n#include <vector>\n#include <algorithm>\n\nstruct Result {\n    int startTime, duration;\n    float value;\n};\n\nbool compareByStartTime(const Result& a, const Result& b) {\n    return a.startTime < b.startTime;\n}\n\nvoid sortByStartTime(std::vector<Result> &results) {\n    std::sort(results.begin(), results.end(), compareByStartTime);\n}\n"}
{"algo": "sort", "spec": "44_sort_sort_non-zero_elements", "prompt": "/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place.\n   Example:\n\n\t input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {", "completion": "\n#include <vector>\n#include <algorithm>\n\nvoid sortIgnoreZero(std::vector<int> &x) {\n    std::vector<int> nonZeroElements;\n    std::vector<int> zeroIndices;\n\n    // Separate non-zero elements and zero indices\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            nonZeroElements.push_back(x[i]);\n        } else {\n            zeroIndices.push_back(i);\n        }\n    }\n\n    // Sort non-zero elements\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n\n    // Place sorted non-zero elements back into the vector\n    size_t nonZeroIndex = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (std::find(zeroIndices.begin(), zeroIndices.end(), i) == zeroIndices.end()) {\n            x[i] = nonZeroElements[nonZeroIndex];\n            ++nonZeroIndex;\n        }\n    }\n}\n"}
{"algo": "sparse_la", "spec": "45_sparse_la_sparse_solve", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Solve the sparse linear system Ax=b for x.\n   A is a sparse NxN matrix in COO format. x and b are dense vectors with N elements.\n   Example:\n   \n   input: A=[{0,0,1}, {0,1,1}, {1,1,-2}] b=[1,4]\n   output: x=[3,-2]\n*/\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {", "completion": "\n#include <vector>\n#include <iostream>\n#include <cstddef>\n#include <Eigen/Sparse>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double>& x, size_t N) {\n    // Build a sparse matrix from COO format\n    Eigen::SparseMatrix<double> sparseA(N, N);\n    std::vector<Eigen::Triplet<double>> tripletList;\n    tripletList.reserve(A.size());\n    for (const auto& element : A) {\n        tripletList.emplace_back(element.row, element.column, element.value);\n    }\n    sparseA.setFromTriplets(tripletList.begin(), tripletList.end());\n\n    // Solve the linear system Ax=b\n    Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;\n    solver.compute(sparseA);\n\n    if (solver.info() != Eigen::Success) {\n        std::cerr << \"Error during decomposition of the sparse matrix.\" << std::endl;\n        return;\n    }\n\n    Eigen::Map<Eigen::VectorXd> bVec(b.data(), N);\n    Eigen::Map<Eigen::VectorXd> xVec(x.data(), N);\n    xVec = solver.solve(bVec);\n\n    std::cout << \"Solution x: \" << xVec.transpose() << std::endl;\n}\n\nint main() {\n    // Example COO format input {0,0,1}, {0,1,1}, {1,1,-2}\n    std::vector<COOElement> A = {{0, 0, 1}, {0, 1, 1}, {1, 1, -2}};\n    std::vector<double> b = {1, 4};\n\n    size_t N = 2; // Size of the square matrix A\n    std::vector<double> x(N);\n\n    solveLinearSystem(A, b, x, N);\n\n    return 0;\n}\n"}
{"algo": "sparse_la", "spec": "46_sparse_la_spmm", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {", "completion": "\n#include <vector>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n    // Initialize the output matrix Y with zeros\n    Y.resize(M * N, 0.0);\n\n    // Perform matrix multiplication\n    for (const auto& elemA : A) {\n        for (const auto& elemX : X) {\n            if (elemA.column == elemX.row) {\n                Y[elemA.row * N + elemX.column] += elemA.value * elemX.value;\n            }\n        }\n    }\n}\n\nint main() {\n    // Example input matrices A and X\n    std::vector<COOElement> A = {{0, 0, -2}, {0, 1, 1}, {1, 1, -1}};\n    std::vector<COOElement> X = {{0, 1, 2}, {1, 0, -1}};\n    \n    // Define the dimensions of the matrices\n    size_t M = 2; // Rows of A, Rows of Y\n    size_t K = 2; // Columns of A, Rows of X\n    size_t N = 2; // Columns of X, Columns of Y\n\n    // Initialize the output matrix Y\n    std::vector<double> Y;\n    \n    // Perform matrix multiplication\n    spmm(A, X, Y, M, K, N);\n\n    // Output the result matrix Y\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            std::cout << Y[i * N + j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "sparse_la", "spec": "47_sparse_la_spmv", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {", "completion": "function performs the Sparse Matrix-Vector Multiplication (SPMV) operation. It computes y = alpha*A*x + beta*y, where A is a sparse matrix in the Coordinate List (COO) format, alpha and beta are scalars, x and y are vectors.\n\nThe function takes the following parameters:\n- `alpha`: Scalar multiplier for the matrix-vector product.\n- `A`: Vector of COOElement representing the sparse matrix A.\n- `x`: Vector representing the input vector x.\n- `beta`: Scalar multiplier for the vector y.\n- `y`: Vector representing the output vector y. It is also the initial value of y that incorporates the existing values.\n- `M`: Number of rows in the matrix A.\n- `N`: Number of columns in the matrix A.\n\nThe function implementation would involve iterating over the COO format sparse matrix elements, computing the matrix-vector product, and applying alpha and beta as specified. The result will be stored in the output vector y.\n\nHere's a basic outline of the implementation:\n1. Initialize all elements in the output vector y with beta*y.\n2. Iterate over the sparse matrix elements in COO format.\n3. For each element in A, calculate the corresponding product and add it to the respective element in y.\n4. Modify the elements in y with the appropriate scalar multipliers alpha and beta.\n\nIf you have any specific questions or need further clarification on any part of the implementation, feel free to ask"}
{"algo": "sparse_la", "spec": "48_sparse_la_sparse_axpy", "prompt": "struct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {", "completion": "\n#include <vector>\n#include <cmath>\n\nstruct Element {\n    size_t index;\n    double value;\n};\n\nvoid sparseAxpy(double alpha, const std::vector<Element>& x, const std::vector<Element>& y, std::vector<double>& z) {\n    // Initialize the result vector z with the same size as the longer of x and y\n    size_t zSize = std::max(x.size(), y.size());\n    z.resize(zSize);\n\n    // Perform the operation z = alpha*x + y\n    for (const Element& elem : x) {\n        z[elem.index] += alpha * elem.value;\n    }\n\n    for (const Element& elem : y) {\n        z[elem.index] += elem.value;\n    }\n}\n"}
{"algo": "sparse_la", "spec": "49_sparse_la_sparse_lu_decomp", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid assembleLU(const std::vector<COOElement> &A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n    L.resize(A.size());\n    U.resize(A.size());\n\n    // Initialize L to identity matrix and U to zeros\n    for (size_t i = 0; i < A.size(); ++i) {\n        if (A[i].row == A[i].column) {\n            L[i] = 1.0;\n            U[i] = A[i].value;\n        } else {\n            L[i] = 0.0;\n            U[i] = 0.0;\n        }\n    }\n\n    // Apply LU decomposition algorithm\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t i = 0; i < A.size(); ++i) {\n            if (A[i].row > k) {\n                continue; // Skip entries above the diagonal\n            }\n\n            if (A[i].column == k) {\n                L[i] = A[i].value / U[k * N + k];\n            } else if (A[i].row == k) {\n                U[i] = A[i].value;\n            } else if (A[i].row < k && A[i].column > k) {\n                U[i] -= L[A[i].row * N + k] * U[k * N + A[i].column];\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<COOElement> A = {{0, 0, 4}, {0, 1, 3}, {1, 0, 6}, {1, 1, 3}};\n    size_t N = 2; // Assuming N = 2 for the given example\n\n    std::vector<double> L, U;\n    assembleLU(A, L, U, N);\n\n    // Output the factorized matrices L and U\n    std::cout << \"L:\\n\";\n    for (const auto &elem : L) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"U:\\n\";\n    for (const auto &elem : U) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"}
{"algo": "stencil", "spec": "50_stencil_xor_kernel", "prompt": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {", "completion": "\n#include <vector>\n\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n\n            if (i > 0 && input[(i - 1) * N + j] == 1) count++; // Check top neighbor\n            if (i < N - 1 && input[(i + 1) * N + j] == 1) count++; // Check bottom neighbor\n            if (j > 0 && input[i * N + (j - 1)] == 1) count++; // Check left neighbor\n            if (j < N - 1 && input[i * N + (j + 1)] == 1) count++; // Check right neighbor\n\n            output[i * N + j] = (count == 1) ? 1 : 0;\n        }\n    }\n}\n"}
{"algo": "stencil", "spec": "51_stencil_edge_kernel", "prompt": "const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {", "completion": "\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    // Helper function to get pixel value at row x, column y in the 1D image vector\n    auto getPixel = [&](int x, int y) -> int {\n        if (x >= 0 && x < N && y >= 0 && y < N) {\n            return imageIn[x * N + y];\n        }\n        return 0;  // Return 0 for pixels outside boundary\n    };\n\n    // Apply edge kernel convolution\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int pixel = getPixel(i + k, j + l);\n                    sum += pixel * edgeKernel[k + 1][l + 1];\n                }\n            }\n            imageOut[i * N + j] = std::max(0, std::min(255, sum)); // Clip the output\n        }\n    }\n}\n"}
{"algo": "stencil", "spec": "52_stencil_1d_jacobi_3-point_stencil", "prompt": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {", "completion": "\n#include <vector>\n\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    int n = input.size();\n\n    // Compute first element\n    output[0] = (n > 1) ? (input[0] + input[1]) / 3.0 : 0.0;\n\n    // Compute middle elements\n    for (int i = 1; i < n - 1; ++i) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3.0;\n    }\n\n    // Compute last element\n    output[n - 1] = (n > 1) ? (input[n - 2] + input[n - 1]) / 3.0 : 0.0;\n}\n"}
{"algo": "stencil", "spec": "53_stencil_2d_jacobi_5-point_stencil", "prompt": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {", "completion": "\n#include <vector>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    // Loop over the 2D grid\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            // Calculate the indices for neighbor elements\n            size_t left = (j == 0) ? 0 : i*N + (j-1);\n            size_t right = (j == N-1) ? 0 : i*N + (j+1);\n            size_t up = (i == 0) ? 0 : (i-1)*N + j;\n            size_t down = (i == N-1) ? 0 : (i+1)*N + j;\n\n            // Compute the Jacobi value of the current element\n            output[i*N + j] = (input[left] + input[right] + input[up] + input[down] + input[i*N + j]) / 5.0;\n        }\n    }\n}\n"}
{"algo": "stencil", "spec": "54_stencil_game_of_life", "prompt": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {", "completion": "\n#include <vector>\n\nvoid gameOfLife(std::vector<int> const& input, std::vector<int>& output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int liveNeighbors = 0;\n            // Check all 8 neighbors around the current cell\n            for (int di = -1; di <= 1; ++di) {\n                for (int dj = -1; dj <= 1; ++dj) {\n                    if (di == 0 && dj == 0) continue; // Skip the current cell\n                    int ni = i + di;\n                    int nj = j + dj;\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        liveNeighbors += input[ni * N + nj];\n                    }\n                }\n            }\n\n            // Apply the rules of the Game of Life\n            if (input[i * N + j] == 1) {\n                if (liveNeighbors < 2 || liveNeighbors > 3) {\n                    output[i * N + j] = 0; // Cell dies\n                } else {\n                    output[i * N + j] = 1; // Cell lives on\n                }\n            } else {\n                if (liveNeighbors == 3) {\n                    output[i * N + j] = 1; // Cell becomes alive\n                } else {\n                    output[i * N + j] = 0; // Cell remains dead\n                }\n            }\n        }\n    }\n}\n"}
{"algo": "transform", "spec": "55_transform_relu", "prompt": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {", "completion": "\n#include <vector>\n\nvoid relu(std::vector<double> &x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] < 0) {\n            x[i] = 0;  // Setting negative values to zero\n        }\n        // Non-negative values stay the same\n    }\n}\n"}
{"algo": "transform", "spec": "56_transform_negate_odds", "prompt": "/* In the vector x negate the odd values and divide the even values by 2.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {", "completion": "\n#include <vector>\n\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    for (int &num : x) {\n        if (num % 2 == 0) {\n            num /= 2;  // divide even numbers by 2\n        } else {\n            num = -num;  // negate odd numbers\n        }\n    }\n}\n"}
{"algo": "transform", "spec": "57_transform_inverse_offset", "prompt": "/* Replace every element of the vector x with 1-1/x.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {", "completion": "\n#include <vector>\n\nvoid oneMinusInverse(std::vector<double> &x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            x[i] = 1.0 - 1.0 / x[i];\n        }\n    }\n}\n"}
{"algo": "transform", "spec": "58_transform_squaring", "prompt": "/* Replace every element of x with the square of its value.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {", "completion": "\n#include <vector>\n\nvoid squareEach(std::vector<int> &x) {\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i]; // Square each element\n    }\n}\n"}
{"algo": "transform", "spec": "59_transform_map_function", "prompt": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {", "completion": "\n#include <vector>\n\nbool isPowerOfTwo(int x) {\n    return (x > 0) && !(x & (x - 1));\n}\n\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    mask.clear();  // Clear the mask vector before populating it\n    mask.reserve(x.size());  // Reserve space for the elements\n\n    for (int num : x) {\n        mask.push_back(isPowerOfTwo(num));\n    }\n}\n\nint main() {\n    std::vector<int> input = {8, 0, 9, 7, 15, 64, 3};\n    std::vector<bool> output;\n\n    mapPowersOfTwo(input, output);\n\n    // Output the results\n    for (size_t i = 0; i < input.size(); ++i) {\n        std::cout << \"Input: \" << input[i] << \", Output: \" << (output[i] ? \"true\" : \"false\") << std::endl;\n    }\n\n    return 0;\n}\n"}
