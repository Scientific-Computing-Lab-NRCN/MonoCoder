{"algo": "dense_la", "spec": "00_dense_la_lu_decomp", "prompt": "/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <omp.h>\n\n// Function to perform LU factorization in parallel\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    #pragma omp parallel for\n    for (size_t k = 0; k < N - 1; ++k) {\n        for (size_t i = k + 1; i < N; ++i) {\n            A[i * N + k] /= A[k * N + k];\n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= A[i * N + k] * A[k * N + j];\n            }\n        }\n    }\n}\n\nint main() {\n    // Define the input matrix\n    std::vector<double> A = {4, 3, 6, 3};\n    size_t N = 2;\n\n    // Perform LU factorization and store the results in A\n    luFactorize(A, N);\n\n    // Print the result (LU factorization stored in place)\n    std::cout << \"LU Factorization result:\" << std::endl;\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            std::cout << A[i * N + j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "dense_la", "spec": "01_dense_la_solve", "prompt": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n"}
{"algo": "dense_la", "spec": "02_dense_la_gemm", "prompt": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid gemm(std::vector<double>& A, std::vector<double>& B, std::vector<double>& C, size_t M, size_t K, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n"}
{"algo": "dense_la", "spec": "03_dense_la_axpy", "prompt": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {", "completion": "\n#include <omp.h>\n#include <vector>\n\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    int size = x.size();\n\n    #pragma omp parallel for\n    for (int i = 0; i < size; i++) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n"}
{"algo": "dense_la", "spec": "04_dense_la_gemv", "prompt": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        y[i] = 0.0;\n        for (size_t j = 0; j < N; ++j) {\n            y[i] += A[i * N + j] * x[j];\n        }\n    }\n}\n"}
{"algo": "fft", "spec": "05_fft_inverse_fft", "prompt": "/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {", "completion": "\n#include <vector>\n#include <complex>\n#include <omp.h>\n\n/* forward declare fft. computes Fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse Fourier transform of x in-place using OpenMP for parallelization */\nvoid ifft(std::vector<std::complex<double>> &x) {\n    // Calculate the size of the input vector\n    int N = x.size();\n\n    // Compute inverse Fourier transform in parallel\n    #pragma omp parallel for\n    for (int k = 0; k < N; ++k) {\n        x[k] = std::conj(x[k]);\n    }\n    \n    // Forward FFT\n    fft(x);\n    \n    // Compute final result and normalize\n    #pragma omp parallel for\n    for (int k = 0; k < N; ++k) {\n        x[k] = std::conj(x[k]) / static_cast<double>(N);\n    }\n}\n"}
{"algo": "fft", "spec": "06_fft_dft", "prompt": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {", "completion": "\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <omp.h>\n\nvoid dft(const std::vector<double> &x, std::vector<std::complex<double>> &output) {\n    size_t N = x.size();\n    output.resize(N, std::complex<double>(0, 0));\n\n    #pragma omp parallel for\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t n = 0; n < N; ++n) {\n            output[k] += x[n] * std::polar(1.0, -2 * M_PI * k * n / N);\n        }\n    }\n}\n"}
{"algo": "fft", "spec": "07_fft_fft_conjugate", "prompt": "/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {", "completion": "\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <omp.h>\n\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\n    int n = x.size();\n    \n    #pragma omp parallel for\n    for (int k = 0; k < n; k++) {\n        for (int j = 0; j < n; j++) {\n            double theta = -2.0 * M_PI * j * k / n;\n            std::complex<double> factor(std::cos(theta), std::sin(theta));\n\n            if (j < k) {\n                std::swap(x[j], x[k]);\n            }\n            x[k] += x[j] * factor;\n        }\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        x[i] = std::conj(x[i]); // Conjugate the imaginary part\n    }\n}\n"}
{"algo": "fft", "spec": "08_fft_split_fft", "prompt": "/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <fftw3.h>\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    int N = x.size();\n    r.resize(N);\n    i.resize(N);\n\n    fftw_complex *in, *out;\n    fftw_plan plan;\n\n    in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * N);\n    out = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * N);\n\n    // Create FFTW plan\n    plan = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    // Fill input array\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        in[i][0] = x[i].real();\n        in[i][1] = x[i].imag();\n    }\n\n    // Execute FFT\n    fftw_execute(plan);\n\n    // Retrieve results\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        r[i] = out[i][0];\n        i[i] = out[i][1];\n    }\n\n    fftw_destroy_plan(plan);\n    fftw_free(in);\n    fftw_free(out);\n}\n\nint main() {\n    // Example input signal\n    std::vector<std::complex<double>> signal = {{1.0, 0.0}, {1.0, 0.0}, {1.0, 0.0}, {1.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}};\n    std::vector<double> real_part, imag_part;\n\n    // Call FFT function\n    fft(signal, real_part, imag_part);\n\n    // Output the results\n    std::cout << \"Real part: \";\n    for (const auto& val : real_part) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::cout << \"Imaginary part: \";\n    for (const auto& val : imag_part) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n\n    return 0;\n}\n"}
{"algo": "fft", "spec": "09_fft_fft_out_of_place", "prompt": "/* Compute the fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {", "completion": "\n#include <vector>\n#include <complex>\n#include <omp.h>\n\nvoid fft(const std::vector<std::complex<double>>& x, std::vector<std::complex<double>>& output) {\n    // Ensure output size matches input size\n    if (x.size() != output.size()) {\n        output.resize(x.size());\n    }\n\n    #pragma omp parallel for\n    for (int k = 0; k < x.size(); ++k) {\n        std::complex<double> sum = 0.0;\n        for (int n = 0; n < x.size(); ++n) {\n            double angle = -2 * M_PI * k * n / x.size();\n            sum += x[n] * std::polar(1.0, angle);\n        }\n        output[k] = sum;\n    }\n}\n"}
{"algo": "geometry", "spec": "10_geometry_convex_hull", "prompt": "struct Point {\n   double x, y;\n};\n\n/* Find the set of points that defined the smallest convex polygon that contains all the points in the vector points. Store the result in `hull`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: [{0, 3}, {4, 4}, {3, 1}, {0, 0}]\n*/\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <omp.h>\n\nstruct Point {\n    double x, y;\n};\n\n// Calculate the cross product of vectors (p1, p2) and (p2, p3)\ndouble crossProduct(const Point& p1, const Point& p2, const Point& p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\n// Sort points based on polar angle from the anchor point\nbool polarSortComparator(const Point& a, const Point& b, const Point& anchor) {\n    double cross = crossProduct(anchor, a, b);\n    if (cross != 0) return cross > 0;\n    // If collinear, put the closest point first\n    return std::hypot(a.x - anchor.x, a.y - anchor.y) < std::hypot(b.x - anchor.x, b.y - anchor.y);\n}\n\n// Construct the convex hull of a set of points using Graham's Scan with parallelization\nvoid convexHull(std::vector<Point> const& points, std::vector<Point>& hull) {\n    hull.clear();\n\n    if (points.size() < 3) { // In case of less than 3 points, convex hull is the input points\n        hull = points;\n        return;\n    }\n\n    // Find the point with the lowest y-coordinate (and leftmost if ties)\n    Point anchor = *std::min_element(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.y < b.y || (a.y == b.y && a.x < b.x);\n    });\n\n    std::vector<Point> sortedPoints = points;\n    \n    // Sort the rest of the points based on polar angle from the anchor point\n    std::sort(sortedPoints.begin(), sortedPoints.end(),\n              [&](const Point& a, const Point& b) {\n                  return polarSortComparator(a, b, anchor);\n              });\n\n    hull.push_back(sortedPoints[0]);\n    hull.push_back(sortedPoints[1]);\n\n    #pragma omp parallel for default(none) shared(hull) shared(sortedPoints) firstprivate(anchor)\n    for (size_t i = 2; i < sortedPoints.size(); ++i) {\n        while (hull.size() >= 2 && crossProduct(*(hull.end() - 2), hull.back(), sortedPoints[i]) <= 0) {\n            #pragma omp critical\n            hull.pop_back();\n        }\n        #pragma omp critical\n        hull.push_back(sortedPoints[i]);\n    }\n}\n"}
{"algo": "geometry", "spec": "11_geometry_convex_hull_perimeter", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the perimeter of the smallest convex polygon that contains all the points in the vector points.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: 13.4477\n*/\ndouble convexHullPerimeter(std::vector<Point> const& points) {", "completion": "\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <omp.h>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    double totalPerimeter = 0.0;\n    int n = points.size();\n\n    // Calculate distances between all pairs of points\n    std::vector<std::vector<double>> distances(n, std::vector<double>(n, 0.0));\n    #pragma omp parallel for collapse(2) shared(distances)\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            distances[i][j] = distances[j][i] = distance(points[i], points[j]);\n        }\n    }\n\n    // Find the convex hull perimeter\n    #pragma omp parallel for reduction(+:totalPerimeter)\n    for (int i = 0; i < n; i++) {\n        double minDist = std::numeric_limits<double>::max();\n        for (int j = 0; j < n; j++) {\n            if (i != j) {\n                minDist = std::min(minDist, distances[i][j]);\n            }\n        }\n        totalPerimeter += minDist;\n    }\n\n    return totalPerimeter;\n}\n"}
{"algo": "geometry", "spec": "12_geometry_smallest_triangle", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <omp.h>\n#include \"Point.h\"  // assuming Point struct is defined in Point.h\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs(A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));\n}\n\ndouble smallestArea(std::vector<Point> const& points) {\n  double minArea = std::numeric_limits<double>::max();\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < points.size(); ++i) {\n    for (size_t j = i + 1; j < points.size(); ++j) {\n      for (size_t k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n\n  return minArea;\n}\n"}
{"algo": "geometry", "spec": "13_geometry_closest_pair_2d", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {", "completion": "\ndouble closestPair(std::vector<Point> const& points) {\n    double minDistance = std::numeric_limits<double>::max();\n    \n    // Use OpenMP for parallel execution\n    #pragma omp parallel for\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            double d = distance(points[i], points[j]); // Calculate the distance between points[i] and points[j]\n            \n            // Update minDistance if a closer pair of points is found\n            #pragma omp critical\n            {\n                minDistance = std::min(minDistance, d);\n            }\n        }\n    }\n\n    return minDistance;\n}\n"}
{"algo": "geometry", "spec": "14_geometry_closest_pair_1d", "prompt": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {", "completion": "\n\tdouble minDistance = std::numeric_limits<double>::max();\n\n\t#pragma omp parallel for\n\tfor (int i = 0; i < x.size(); ++i) {\n\t\tfor (int j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < minDistance) {\n\t\t\t\t\tminDistance = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minDistance;\n}\n"}
{"algo": "graph", "spec": "15_graph_edge_count", "prompt": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {", "completion": "\n#include <omp.h>\n#include <vector>\n\nint edgeCount(std::vector<int> const& A, size_t N) {\n    int count = 0;\n    \n    #pragma omp parallel for reduction(+:count)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            if (A[i * N + j] == 1) {\n                #pragma omp critical\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"algo": "graph", "spec": "16_graph_largest_component", "prompt": "/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n"}
{"algo": "graph", "spec": "17_graph_highest_degree", "prompt": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nint maxDegree(std::vector<int> const& A, size_t N) {\n    int max_degree = 0;\n\n    #pragma omp parallel for reduction(max: max_degree)\n    for (size_t i = 0; i < N; ++i) {\n        int node_degree = 0;\n        for (size_t j = 0; j < N; ++j) {\n            if (A[i * N + j] != 0) {\n                // Assuming undirected graph, so each edge contributes 2 to the degree\n                node_degree += 2;\n            }\n        }\n        // Adjust for the loopback edge if any\n        if (A[i * N + i] != 0) {\n            node_degree--;\n        }\n        max_degree = std::max(max_degree, node_degree);\n    }\n\n    return max_degree;\n}\n"}
{"algo": "graph", "spec": "18_graph_count_components", "prompt": "/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n\t Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid dfs(int node, std::vector<int> const& A, std::vector<bool>& visited, size_t N) {\n    visited[node] = true;\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        if (A[node * N + i] && !visited[i]) {\n            dfs(i, A, visited, N);\n        }\n    }\n}\n\nint componentCount(std::vector<int> const& A, size_t N) {\n    int components = 0;\n    std::vector<bool> visited(N, false);\n\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp parallel for\n            for (int j = 0; j < N; ++j) {\n                if (A[i * N + j] && !visited[j]) {\n                    dfs(j, A, visited, N);\n                }\n            }\n            components++;\n        }\n    }\n\n    return components;\n}\n"}
{"algo": "graph", "spec": "19_graph_shortest_path", "prompt": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {", "completion": "\n#include <omp.h>\n#include <vector>\n#include <queue>\n\nint shortestPathLength(const std::vector<int>& A, size_t N, int source, int dest) {\n    std::vector<bool> visited(N, false);\n    std::vector<int> dist(N, -1);\n    \n    std::queue<int> q;\n    visited[source] = true;\n    dist[source] = 0;\n    q.push(source);\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        \n        #pragma omp parallel for\n        for (int i = 0; i < N; i++) {\n            if (A[curr * N + i] && !visited[i]) {\n                visited[i] = true;\n                dist[i] = dist[curr] + 1;\n                q.push(i);\n            }\n        }\n    }\n    \n    return dist[dest];\n}\n\nint main() {\n    // Example input\n    std::vector<int> A = {{0, 1, 1, 0}, {1, 0, 0, 1}, {1, 0, 0, 1}, {0, 1, 1, 0}};\n    size_t N = 4;\n    int source = 0, dest = 3;\n    \n    int shortestLength = shortestPathLength(A, N, source, dest);\n    std::cout << \"Shortest path length from source to dest: \" << shortestLength << std::endl;\n    \n    return 0;\n}\n"}
{"algo": "histogram", "spec": "20_histogram_pixel_histogram", "prompt": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {", "completion": "\n#include <vector>\n#include <array>\n#include <omp.h>\n\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n    // Initialize the bins to zeros\n    #pragma omp parallel for\n    for (int i = 0; i < 256; ++i) {\n        bins[i] = 0;\n    }\n\n    // Count the pixels in the image\n    #pragma omp parallel for\n    for (size_t idx = 0; idx < image.size(); ++idx) {\n        #pragma omp atomic\n        ++bins[image[idx]];\n    }\n}\n\nint main() {\n    std::vector<int> image = {2, 116, 201, 11, 92, 92, 201, 4, 2};\n    std::array<size_t, 256> bins;\n\n    pixelCounts(image, bins);\n\n    // Output the counts\n    for (int i = 0; i < 256; ++i) {\n        std::cout << \"Intensity \" << i << \": \" << bins[i] << \" pixels\" << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "histogram", "spec": "21_histogram_bin_0-100", "prompt": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <array>\n#include <omp.h>\n\nvoid binsBy10Count(const std::vector<double>& x, std::array<size_t, 10>& bins) {\n    // Initialize bins to zeros\n    bins.fill(0);\n\n    // Use OpenMP to parallelize the computation\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        int bin = x[i] / 10; // Determine the bin index for the value\n        #pragma omp atomic\n        ++bins[bin];\n    }\n}\n\nint main() {\n    std::vector<double> input = {7, 32, 95, 12, 39, 32, 11, 71, 70, 66};\n    std::array<size_t, 10> bins;\n\n    binsBy10Count(input, bins);\n\n    // Output the result\n    for (size_t i = 0; i < bins.size(); ++i) {\n        std::cout << bins[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"}
{"algo": "histogram", "spec": "22_histogram_count_quadrants", "prompt": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {", "completion": "\n#include <omp.h>\n#include <vector>\n#include <array>\n\nstruct Point {\n    double x, y;\n};\n\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n    bins.fill(0);\n    \n    #pragma omp parallel for\n    for (size_t i = 0; i < points.size(); i++) {\n        Point const& p = points[i];\n        int quadrant = 0;\n\n        if (p.x > 0 && p.y > 0) {\n            quadrant = 0;\n        } else if (p.x < 0 && p.y > 0) {\n            quadrant = 1;\n        } else if (p.x < 0 && p.y < 0) {\n            quadrant = 2;\n        } else if (p.x > 0 && p.y < 0) {\n            quadrant = 3;\n        }\n        \n        #pragma omp atomic\n        bins[quadrant]++;\n    }\n}\n"}
{"algo": "histogram", "spec": "23_histogram_first_letter_counts", "prompt": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <array>\n#include <omp.h>\n\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < 26; ++i) {\n        bins[i] = 0;\n        for (const std::string& str : s) {\n            if (str.front() == 'a' + i) {\n                #pragma omp atomic\n                ++bins[i];\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> input = {\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"};\n    std::array<size_t, 26> output {};\n\n    firstLetterCounts(input, output);\n\n    // Output the result\n    for (size_t i = 0; i < output.size(); ++i) {\n        std::cout << output[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"}
{"algo": "histogram", "spec": "24_histogram_count_quartile", "prompt": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {", "completion": "\n#include <vector>\n#include <array>\n#include <omp.h>\n\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    bins.fill(0); // Initialize bins to 0\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        double val = x[i];\n        double fractionalPart = val - static_cast<int>(val); // Compute fractional part\n\n        if (fractionalPart < 0.25) {\n            #pragma omp atomic\n            ++bins[0];\n        } else if (fractionalPart < 0.5) {\n            #pragma omp atomic\n            ++bins[1];\n        } else if (fractionalPart < 0.75) {\n            #pragma omp atomic\n            ++bins[2];\n        } else {\n            #pragma omp atomic\n            ++bins[3];\n        }\n    }\n}\n"}
{"algo": "reduce", "spec": "25_reduce_xor", "prompt": "/* Return the logical XOR reduction of the vector of bools x.\n   Use OpenMP to reduce in parallel.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n    bool result = false;  // Initialize result assuming all elements are false\n\n    #pragma omp parallel for reduction(^:result)\n    for (size_t i = 0; i < x.size(); ++i) {\n        result ^= x[i];\n    }\n\n    return result;\n}\n"}
{"algo": "reduce", "spec": "26_reduce_product_of_inverses", "prompt": "/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Use OpenMP to compute product in parallel.\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\ndouble productWithInverses(std::vector<double> const& x) {\n    double product = 1.0;\n\n    #pragma omp parallel for reduction(*:product)\n    for (int i = 0; i < x.size(); i++) {\n        if (i % 2 == 0) {\n            product *= x[i];\n        } else {\n            product /= x[i];\n        }\n    }\n\n    return product;\n}\n"}
{"algo": "reduce", "spec": "27_reduce_average", "prompt": "/* Return the average of the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {", "completion": "\n#include <vector>\n#include <numeric>\n#include <omp.h>\n\ndouble average(std::vector<double> const& x) {\n    double sum = 0.0;\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += x[i];\n    }\n\n    return sum / x.size();\n}\n"}
{"algo": "reduce", "spec": "28_reduce_smallest_odd_number", "prompt": "/* Return the value of the smallest odd number in the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {", "completion": "\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <omp.h>\n\nint smallestOdd(std::vector<int> const& x) {\n    int smallestOddNum = std::numeric_limits<int>::max();\n\n    #pragma omp parallel for\n    for(size_t i = 0; i < x.size(); ++i) {\n        if(x[i] % 2 != 0 && x[i] < smallestOddNum) {\n            #pragma omp critical\n            {\n                if(x[i] < smallestOddNum) {\n                    smallestOddNum = x[i];\n                }\n            }\n        }\n    }\n    \n    return smallestOddNum;\n}\n"}
{"algo": "reduce", "spec": "29_reduce_sum_of_min_of_pairs", "prompt": "/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Use OpenMP to sum in parallel.\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n    size_t size = x.size();\n    double sum = 0.0;\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < size; ++i) {\n        sum += std::min(x[i], y[i]);\n    }\n\n    return sum;\n}\n"}
{"algo": "scan", "spec": "30_scan_prefix_sum", "prompt": "/* Compute the prefix sum of the vector x into output.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n    output.resize(x.size());\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        output[i] = x[i] + (i > 0 ? output[i - 1] : 0);\n    }\n}\n"}
{"algo": "scan", "spec": "31_scan_scan_with_min_function", "prompt": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {", "completion": "\nvoid partialMinimums(std::vector<float> &x) {\n    // Get the size of the vector\n    int n = x.size();\n\n    // Parallelize the loop\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        float min_val = x[0]; // Initialize minimum value to the first element\n        for (int j = 1; j <= i; j++) {\n            min_val = std::min(min_val, x[j]);\n        }\n        x[i] = min_val; // Update the i-th element with the minimum value from 0 to i\n    }\n}\n"}
{"algo": "scan", "spec": "32_scan_sum_of_prefix_sum_array", "prompt": "/* Compute the prefix sum array of the vector x and return its sum.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n    int n = x.size();\n    std::vector<double> prefixSum(n);\n    \n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0) + x[i];\n    }\n\n    double sum = 0.0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < n; ++i) {\n        sum += prefixSum[i];\n    }\n\n    return sum;\n}\n\nint main() {\n    std::vector<double> input = {-7, 2, 1, 9, 4, 8};\n    double result = sumOfPrefixSum(input);\n\n    // Output the result\n    std::cout << \"Sum of the prefix sum array: \" << result << std::endl;\n\n    return 0;\n}\n"}
{"algo": "scan", "spec": "33_scan_reverse_prefix_sum", "prompt": "/* Compute the reverse prefix sum of the vector x into output.\n   Use OpenMP to compute in parallel.\n   Examples:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [2, 8, 14, 18, 25, 26]\n\n   input: [3, 3, 7, 1, -2]\n   output: [-2, -1, 6, 9, 12]\n*/\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    int size = x.size();\n    output.resize(size);\n\n    // Compute the reverse prefix sum in parallel using OpenMP\n    #pragma omp parallel for\n    for (int i = size - 1; i >= 0; i--) {\n        if (i == size - 1) {\n            output[i] = x[i];\n        } else {\n            output[i] = output[i + 1] + x[i];\n        }\n    }\n}\n\n// You can use this function to test the reverse prefix sum computation\nvoid testReversePrefixSum() {\n    std::vector<int> input1 = {1, 7, 4, 6, 6, 2};\n    std::vector<int> input2 = {3, 3, 7, 1, -2};\n    std::vector<int> output1, output2;\n\n    reversePrefixSum(input1, output1);\n    reversePrefixSum(input2, output2);\n\n    // Display the results\n    for (int num : output1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    for (int num : output2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    testReversePrefixSum();\n    return 0;\n}\n"}
{"algo": "scan", "spec": "34_scan_largest_contiguous_subarray_sum", "prompt": "/* Return the largest sum of any contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4] then [4, \u22121, 2, 1] is the contiguous\n   subarray with the largest sum of 6.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4]\n   output: 6\n*/\nint maximumSubarray(std::vector<int> const& x) {", "completion": "\n#include <vector>\n#include <iostream>\n#include <omp.h>\n\nint maximumSubarray(std::vector<int> const& x) {\n    int max_ending_here = x[0];\n    int max_so_far = x[0];\n\n    #pragma omp parallel for\n    for (int i = 1; i < x.size(); ++i) {\n        max_ending_here = std::max(x[i], max_ending_here + x[i]);\n        max_so_far = std::max(max_so_far, max_ending_here);\n    }\n\n    return max_so_far;\n}\n\nint main() {\n    std::vector<int> x = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    int result = maximumSubarray(x);\n    std::cout << \"Maximum sum of contiguous subarray: \" << result << std::endl;\n\n    return 0;\n}\n"}
{"algo": "search", "spec": "35_search_search_for_last_struct_by_key", "prompt": "struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {", "completion": "\n#include <omp.h>\n#include <vector>\n#include <string>\n\nstruct Book {\n    std::string title;\n    int pages;\n};\n\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    // Initialize a variable to store the index of the last short book\n    size_t lastShortBookIndex = 0;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].pages < 100) {\n            // Critical section to update the lastShortBookIndex\n            #pragma omp critical\n            {\n                lastShortBookIndex = i;\n            }\n        }\n    }\n\n    return lastShortBookIndex;\n}\n\nint main() {\n    std::vector<Book> books = {\n        {\"Green Eggs and Ham\", 72},\n        {\"gulliver's travels\", 362},\n        {\"Stories of Your Life\", 54},\n        {\"Hamilton\", 818}\n    };\n\n    size_t lastShortBookIndex = findLastShortBook(books);\n    \n    // Output the index of the last short book\n    std::cout << \"Index of the last short book: \" << lastShortBookIndex << std::endl;\n\n    return 0;\n}\n"}
{"algo": "search", "spec": "36_search_check_if_array_contains_value", "prompt": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nbool contains(std::vector<int> const& x, int target) {\n    bool result = false;\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            #pragma omp critical\n            {\n                result = true;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"algo": "search", "spec": "37_search_find_the_closest_number_to_pi", "prompt": "/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {", "completion": "\n#include <vector>\n#include <cmath>\n#include <omp.h>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    // Initialize variables for minimum difference and index\n    double minDiff = std::abs(M_PI - x[0]);\n    size_t index = 0;\n\n    // Use OpenMP to parallelize the search for the closest value to PI\n#pragma omp parallel for\n    for (size_t i = 1; i < x.size(); ++i) {\n        double diff = std::abs(M_PI - x[i]);\n        if (diff < minDiff) {\n            // Update the minimum difference and index if a closer value is found\n#pragma omp critical\n            {\n                if (diff < minDiff) {\n                    minDiff = diff;\n                    index = i;\n                }\n            }\n        }\n    }\n\n    return index;\n}\n"}
{"algo": "search", "spec": "38_search_find_the_first_even_number", "prompt": "/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nsize_t findFirstEven(std::vector<int> const& x) {\n    size_t index = x.size();\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < index) {\n                    index = i;\n                }\n            }\n        }\n    }\n\n    return index;\n}\n"}
{"algo": "search", "spec": "39_search_xor_contains", "prompt": "/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {", "completion": "\n#include <vector>\n#include <iostream>\n#include <omp.h>\n\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool foundInX = false;\n    bool foundInY = false;\n\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] == val) {\n            #pragma omp atomic write\n            foundInX = true;\n        }\n    }\n\n#pragma omp parallel for\n    for (size_t i = 0; i < y.size(); ++i) {\n        if (y[i] == val) {\n            #pragma omp atomic write\n            foundInY = true;\n        }\n    }\n    \n    if ((foundInX && !foundInY) || (!foundInX && foundInY)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    std::vector<int> x = {1, 8, 4, 3, 2};\n    std::vector<int> y = {3, 4, 4, 1, 1, 7};\n    int val = 7;\n    \n    bool result = xorContains(x, y, val);\n    \n    if (result) {\n        std::cout << \"true\\n\";\n    } else {\n        std::cout << \"false\\n\";\n    }\n\n    return 0;\n}\n"}
{"algo": "sort", "spec": "40_sort_sort_an_array_of_complex_numbers_by_magnitude", "prompt": "/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {", "completion": "\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <omp.h>\n\nbool compareByMagnitude(const std::complex<double> &a, const std::complex<double> &b) {\n    return std::abs(a) < std::abs(b);\n}\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    // Sort the vector x by magnitude in parallel using OpenMP\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        x[i] = std::complex<double>(std::abs(x[i]), 0.0);\n    }\n\n    std::sort(x.begin(), x.end(), compareByMagnitude);\n}\n\nint main() {\n    // Example input\n    std::vector<std::complex<double>> input = { {3.0, -1.0}, {4.5, 2.1}, {0.0, -1.0}, {1.0, 0.0}, {0.5, 0.5} };\n\n    sortComplexByMagnitude(input);\n\n    // Output the sorted vector\n    for (const auto &num : input) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"}
{"algo": "sort", "spec": "41_sort_k-th_smallest_element", "prompt": "/* Find the k-th smallest element of the vector x.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nint findKthSmallest(std::vector<int> const& x, int k) {\n    int result = 0;\n\n    #pragma omp parallel\n    {\n        std::vector<int> localX(x);\n\n        #pragma omp single\n        {\n            std::sort(localX.begin(), localX.end());\n        }\n\n        #pragma omp single\n        {\n            result = localX[k - 1];\n        }\n    }\n\n    return result;\n}\n"}
{"algo": "sort", "spec": "42_sort_sorted_ranks", "prompt": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n    // Create a temporary vector to store the sorted indices\n    std::vector<size_t> temp(x.size());\n\n    // Initialize ranks vector to be the same size as x\n    ranks.resize(x.size());\n\n    // Create a vector of indices [0, 1, 2, ..., x.size()-1]\n    std::iota(temp.begin(), temp.end(), 0);\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        // Sort indices based on the values in x\n        std::sort(temp.begin(), temp.end(), [&x](size_t a, size_t b) {\n            return x[a] < x[b];\n        });\n\n        // Find the rank of the current element in the sorted array\n        size_t rank = 0;\n        while (temp[rank] != i) {\n            ++rank;\n        }\n\n        // Store the rank in the ranks vector\n        ranks[i] = rank;\n    }\n}\n"}
{"algo": "sort", "spec": "43_sort_sort_an_array_of_structs_by_key", "prompt": "struct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\nbool compareByStartTime(const Result &a, const Result &b) {\n    return a.startTime < b.startTime;\n}\n\nvoid sortByStartTime(std::vector<Result> &results) {\n    #pragma omp parallel for\n    for (int i = 0; i < results.size(); ++i) {\n        #pragma omp for\n        for (int j = i + 1; j < results.size(); ++j) {\n            if (results[i].startTime > results[j].startTime) {\n                std::swap(results[i], results[j]);\n            }\n        }\n    }\n\n    // Alternatively, you can use the STL sort function for better performance\n    // std::sort(results.begin(), results.end(), compareByStartTime);\n}\n"}
{"algo": "sort", "spec": "44_sort_sort_non-zero_elements", "prompt": "/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place. \n\t Use OpenMP to sort x in parallel. \n   Example:\n\n   input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nvoid sortIgnoreZero(std::vector<int> &x) {\n    std::vector<int> nonZeroElements;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            #pragma omp critical\n            nonZeroElements.push_back(x[i]);\n        }\n    }\n\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n\n    size_t j = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            x[i] = nonZeroElements[j++];\n        }\n    }\n}\n"}
{"algo": "sparse_la", "spec": "45_sparse_la_sparse_solve", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Solve the sparse linear system Ax=b for x.\n   A is a sparse NxN matrix in COO format. x and b are dense vectors with N elements.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: A=[{0,0,1}, {0,1,1}, {1,1,-2}] b=[1,4]\n   output: x=[3,-2]\n*/\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    // Convert COO to CSR\n    std::vector<size_t> row_ptr(N+1, 0);\n    std::vector<size_t> col_idx;\n    std::vector<double> values;\n    for (const COOElement& elem : A) {\n        col_idx.push_back(elem.column);\n        values.push_back(elem.value);\n        row_ptr[elem.row + 1]++;\n    }\n    for (size_t i = 1; i <= N; ++i) {\n        row_ptr[i] += row_ptr[i - 1];\n    }\n\n    // Initialize x with zeros\n    x.assign(N, 0.0);\n\n    // Solve Ax = b using OpenMP parallelization\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (size_t j = row_ptr[i]; j < row_ptr[i + 1]; ++j) {\n            sum += values[j] * x[col_idx[j]];\n        }\n        x[i] = sum;\n    }\n\n    // Back substitution (if needed)\n}\n\nint main() {\n    size_t N = 2;\n    std::vector<COOElement> A = {{0, 0, 1.0}, {0, 1, 1.0}, {1, 1, -2.0}};\n    std::vector<double> b = {1.0, 4.0};\n    std::vector<double> x(N);\n\n    solveLinearSystem(A, b, x, N);\n\n    // Print the result vector x\n    for (size_t i = 0; i < N; ++i) {\n        std::cout << \"x[\" << i << \"] = \" << x[i] << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "sparse_la", "spec": "46_sparse_la_spmm", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {", "completion": "\n#include <vector>\n#include <iostream>\n#include <omp.h>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n    // Step 1: Initialize the output matrix Y\n    #pragma omp parallel for\n    for (size_t i = 0; i < M * N; ++i) {\n        Y[i] = 0.0;\n    }\n\n    // Step 2: Compute matrix product Y=AX\n    #pragma omp parallel for\n    for (size_t i = 0; i < A.size(); ++i) {\n        size_t rowA = A[i].row;\n        size_t colA = A[i].column;\n        double valA = A[i].value;\n\n        for (size_t j = 0; j < X.size(); ++j) {\n            size_t colX = X[j].column;\n            double valX = X[j].value;\n\n            if (colA == colX) {\n                size_t rowY = rowA;\n                size_t colY = X[j].row;\n                Y[rowY * N + colY] += valA * valX;\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<COOElement> A = {{0, 0, -2}, {0, 1, 1}, {1, 1, -1}};\n    std::vector<COOElement> X = {{0, 1, 2}, {1, 0, -1}};\n    size_t M = 2, K = 2, N = 2;\n    std::vector<double> Y(M * N, 0.0);\n\n    spmm(A, X, Y, M, K, N);\n\n    // Output the result matrix Y\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            std::cout << Y[i * N + j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n"}
{"algo": "sparse_la", "spec": "47_sparse_la_spmv", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use OpenMP to parallelize.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {", "completion": "\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < A.size(); ++j) {\n            if (A[j].row == i) {\n                sum += A[j].value * x[A[j].column];\n            }\n        }\n        y[i] = alpha * sum + beta * y[i];\n    }\n}\n"}
{"algo": "sparse_la", "spec": "48_sparse_la_sparse_axpy", "prompt": "struct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nstruct Element {\n    size_t index;\n    double value;\n};\n\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double>& z) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        z[x[i].index] = alpha * x[i].value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < y.size(); ++i) {\n        z[y[i].index] += y[i].value;\n    }\n}\n"}
{"algo": "sparse_la", "spec": "49_sparse_la_sparse_lu_decomp", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {", "completion": "\n#include <omp.h>\n#include <vector>\n\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n    // Initialize L and U matrices\n    L.clear(); L.resize(N * N, 0.0);\n    U.clear(); U.resize(N * N, 0.0);\n\n    // Set the main diagonal of L to 1\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        L[i * N + i] = 1.0;\n    }\n\n    // Copy elements from A to U\n    #pragma omp parallel for\n    for (size_t i = 0; i < A.size(); ++i) {\n        U[A[i].row * N + A[i].column] = A[i].value;\n    }\n\n    // Perform LU factorization\n    #pragma omp parallel for\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t j = k+1; j < N; ++j) {\n            L[j * N + k] = U[j * N + k] / U[k * N + k];\n            for (size_t i = k; i < N; ++i) {\n                U[j * N + i] -= L[j * N + k] * U[k * N + i];\n            }\n        }\n    }\n}\n"}
{"algo": "stencil", "spec": "50_stencil_xor_kernel", "prompt": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    #pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int neighbors = 0;\n\n            // Check neighbors on all sides (top, bottom, left, right)\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1; ++dy) {\n                    if (dx == 0 && dy == 0) continue; // Skip the cell itself\n                    int ni = i + dx;\n                    int nj = j + dy;\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N && input[ni * N + nj] == 1) {\n                        neighbors++;\n                    }\n                }\n            }\n\n            if (neighbors == 1) {\n                output[i * N + j] = 1;\n            } else {\n                output[i * N + j] = 0;\n            }\n        }\n    }\n}\n"}
{"algo": "stencil", "spec": "51_stencil_edge_kernel", "prompt": "const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {", "completion": "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; losh<= 1; ++l) {\n                    int iIndex = std::max(0, std::min(N - 1, i + k));\n                    int jIndex = std::max(0, std::min(N - 1, j + l));\n                    sum += edgeKernel[k + 1][l + 1] * imageIn[iIndex * N + jultIndex];\n                }\n            }\n            sum = std::min(std::max(sum, 0), 255);\n            imageOut[i * N + j] = sum;\n        }\n    }\n}\n"}
{"algo": "stencil", "spec": "52_stencil_1d_jacobi_3-point_stencil", "prompt": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    int n = input.size();\n\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        double left = i > 0 ? input[i - 1] : 0;\n        double right = i < n - 1 ? input[i + 1] : 0;\n        output[i] = (left + input[i] + right) / 3.0;\n    }\n}\n"}
{"algo": "stencil", "spec": "53_stencil_2d_jacobi_5-point_stencil", "prompt": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    #pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            double current_sum = input[i * N + j];\n            double neighbor_sum = 0.0;\n            int count = 1;\n\n            // Neighbor to the left\n            if (j > 0) {\n                neighbor_sum += input[i * N + (j - 1)];\n                count++;\n            }\n\n            // Neighbor to the right\n            if (j < N - 1) {\n                neighbor_sum += input[i * N + (j + 1)];\n                count++;\n            }\n\n            // Neighbor above\n            if (i > 0) {\n                neighbor_sum += input[(i - 1) * N + j];\n                count++;\n            }\n\n            // Neighbor below\n            if (i < N - 1) {\n                neighbor_sum += input[(i + 1) * N + j];\n                count++;\n            }\n\n            output[i * N + j] = (current_sum + neighbor_sum) / count;\n        }\n    }\n}\n"}
{"algo": "stencil", "spec": "54_stencil_game_of_life", "prompt": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {", "completion": "\n    #pragma omp parallel for collapse(2)  // Use OpenMP for parallel computation\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int liveNeighbors = 0;\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1; ++dy) {\n                    if (dx == 0 && dy == 0) continue;  // Skip the current cell\n                    int newX = i + dx;\n                    int newY = j + dy;\n                    if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                        liveNeighbors += input[newX * N + newY];\n                    }\n                }\n            }\n\n            if (input[i * N + j] == 1) {  // Current cell is alive\n                if (liveNeighbors < 2 || liveNeighbors > 3) {\n                    output[i * N + j] = 0;  // Cell dies\n                } else {\n                    output[i * N + j] = 1;  // Cell lives on\n                }\n            } else {  // Current cell is dead\n                if (liveNeighbors == 3) {\n                    output[i * N + j] = 1;  // Cell becomes alive\n                } else {\n                    output[i * N + j] = 0;  // Cell remains dead\n                }\n            }\n        }\n    }\n}\n"}
{"algo": "transform", "spec": "55_transform_relu", "prompt": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid relu(std::vector<double> &x) {\n    // Specify that we want to parallelize the for loop\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        // Apply ReLU function\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}\n"}
{"algo": "transform", "spec": "56_transform_negate_odds", "prompt": "/* In the vector x negate the odd values and divide the even values by 2.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n"}
{"algo": "transform", "spec": "57_transform_inverse_offset", "prompt": "/* Replace every element of the vector x with 1-1/x.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid oneMinusInverse(std::vector<double> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        x[i] = 1.0 - 1.0 / x[i];\n    }\n}\n"}
{"algo": "transform", "spec": "58_transform_squaring", "prompt": "/* Replace every element of x with the square of its value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {", "completion": "\n#include <vector>\n#include <omp.h>\n\nvoid squareEach(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}\n"}
{"algo": "transform", "spec": "59_transform_map_function", "prompt": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {", "completion": "\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        mask[i] = isPowerOfTwo(x[i]);\n    }\n}\n"}
