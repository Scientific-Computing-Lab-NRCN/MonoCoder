{"algo": "dense_la", "spec": "00_dense_la_lu_decomp", "prompt": "/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {", "completion": "Here is the implementation to factorize the given NxN matrix A into LU decomposition where L is a lower triangular matrix and U is an upper triangular matrix.\n\n```cpp\n#include <vector>\n#include <iostream>\n\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t i = k + 1; i < N; ++i) {\n            A[i * N + k] /= A[k * N + k];\n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= A[i * N + k] * A[k * N + j];\n            }\n        }\n    }\n\n    std::cout << \"Matrix L + U: \\n\";\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            if (j < i) {\n                // Below diagonal (L)\n                std::cout << A[i * N + j] << \"\\t\";\n            } else {\n                // Above or on diagonal (U)\n                std::cout << A[i * N + j] << \"\\t\";\n            }\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nint main() {\n    std::vector<double> A = {4, 3, 6, 3}; // NxN matrix data in row-major order\n    size_t N = 2; // Size of the matrix\n\n    luFactorize(A, N);\n\n    return 0;\n}\n```\n\nThis code performs LU decomposition on the provided matrix A. It factorizes A into L and U matrices stored in the same vector A. The result is then printed out as the combination of L and U matrices. You can run this code with the given example input `[[4, 3], [6, 3]]` to see the LU decomposition result.\n\nLet me know if you need further assistance or modifications."}
{"algo": "dense_la", "spec": "01_dense_la_solve", "prompt": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {", "completion": "To solve the linear system Ax = b for x using Gaussian elimination, you can use the following steps inside the solveLinearSystem function:\n\n1. Convert the input vectors A and b into a 2D matrix A_matrix.\n2. Perform Gaussian elimination on the augmented matrix [A_matrix | b] to convert it into row-echelon form.\n3. Back-substitute to get the values of x.\n\nHere is the implementation for the function:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    // Convert the row-major vector A to a 2D matrix A_matrix\n    std::vector<std::vector<double>> A_matrix(N, std::vector<double>(N));\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            A_matrix[i][j] = A[i * N + j];\n        }\n    }\n\n    // Gaussian elimination\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = i + 1; j < N; j++) {\n            double ratio = A_matrix[j][i] / A_matrix[i][i];\n            for (size_t k = 0; k < N; k++) {\n                A_matrix[j][k] -= ratio * A_matrix[i][k];\n            }\n            b[j] -= ratio * b[i];\n        }\n    }\n\n    // Back-substitution to get x\n    x.resize(N);\n    for (int i = N - 1; i >= 0; i--) {\n        x[i] = b[i];\n        for (size_t j = i + 1; j < N; j++) {\n            x[i] -= A_matrix[i][j] * x[j];\n        }\n        x[i] /= A_matrix[i][i];\n    }\n}\n\nint main() {\n    std::vector<double> A = {1, 4, 2, 1, 2, 3, 2, 1, 3};\n    std::vector<double> b = {11, 11, 13};\n    std::vector<double> x;\n\n    size_t N = 3;\n    solveLinearSystem(A, b, x, N);\n\n    for (size_t i = 0; i < N; i++) {\n        std::cout << \"x[\" << i << \"] = \" << x[i] << std::endl;\n    }\n\n    return 0;\n}\n```\n\nYou can run this code to solve the linear system Ax = b using Gaussian elimination method."}
{"algo": "dense_la", "spec": "02_dense_la_gemm", "prompt": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {", "completion": "To multiply the matrix A by the matrix B and store the results in matrix C, you can use the following code snippet:\n\n```cpp\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            C[i * N + j] = 0;\n            for (size_t k = 0; k < K; ++k) {\n                C[i * N + j] += A[i * K + k] * B[k * N + j];\n            }\n        }\n    }\n}\n```\n\nIn this code snippet:\n- The function `gemm` takes the matrices A and B as input vectors storing the matrices in row-major form and the matrix C as an output vector.\n- The function also takes the dimensions M (rows of A), K (columns of A/rows of B), and N (columns of B) as inputs.\n- It then performs matrix multiplication by iterating over the elements of the matrices A, B, and C, multiplying corresponding elements and summing the products to populate the elements of matrix C.\n\nYou can now call this function with the input matrices A and B along with their dimensions to obtain the resulting matrix C."}
{"algo": "dense_la", "spec": "03_dense_la_axpy", "prompt": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {", "completion": "To implement the function axpy as described in the comment, you can use the following code snippet. This code calculates the array z = alpha*x + y:\n\n```cpp\n#include <vector>\n\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    // Check if the sizes of x and y are compatible\n    if (x.size() != y.size()) {\n        // Handle the error (e.g., throw an exception or return an error code)\n        return;\n    }\n\n    // Resize z to match the size of x and y\n    z.resize(x.size());\n\n    // Compute z = alpha*x + y\n    for (size_t i = 0; i < x.size(); ++i) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n\nint main() {\n    // Example usage\n    std::vector<double> x = {1, -5, 2, 9};\n    std::vector<double> y = {0, 4, 1, -1};\n    std::vector<double> z;\n\n    double alpha = 2;\n    axpy(alpha, x, y, z);\n\n    // Print the result\n    for (double result : z) {\n        std::cout << result << \" \";\n    }\n\n    return 0;\n}\n``` \n\nYou can further modify the error handling in the `axpy` function based on the requirements of your application."}
{"algo": "dense_la", "spec": "04_dense_la_gemv", "prompt": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {", "completion": "To perform the matrix-vector multiplication as described in the comment, you can utilize the following C++ function implementation:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nvoid gemv(const std::vector<double>& A, const std::vector<double>& x, std::vector<double>& y, size_t M, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        y[i] = 0;\n        for (size_t j = 0; j < N; ++j) {\n            y[i] += A[i * N + j] * x[j];\n        }\n    }\n}\n\nint main() {\n    // Example input\n    std::vector<double> A = {1, -1, 2, 0, -3, 1};\n    std::vector<double> x = {2, 1, 0};\n    std::vector<double> y(2); // Size M = 2\n\n    // Perform the matrix-vector multiplication\n    gemv(A, x, y, 2, 3);\n\n    // Display the result\n    std::cout << \"Result y = [\";\n    for (size_t i = 0; i < y.size(); ++i) {\n        std::cout << y[i] << (i < y.size() - 1 ? \", \" : \"\");\n    }\n    std::cout << \"]\" << std::endl;\n\n    return 0;\n}\n```\n\nThis code snippet defines the `gemv` function to perform the matrix-vector multiplication as specified and provides an example in the `main` function. You can adapt this implementation to accommodate your specific requirements."}
{"algo": "fft", "spec": "05_fft_inverse_fft", "prompt": "/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {", "completion": "To implement the `ifft` function for computing the inverse Fourier transform in-place, you can follow these steps:\n\n1. Include the necessary header file for complex numbers:\n   ```cpp\n   #include <complex>\n   ```\n\n2. Define the function `ifft` and call the `fft` function for performing the forward Fourier transform on the input vector in-place. Then, compute the inverse transform by conjugating each complex number and dividing by the size of the input vector.\n\n3. Implement the `ifft` function as follows:\n   ```cpp\n   void ifft(std::vector<std::complex<double>> &x) {\n       // Perform the forward FFT to utilize existing implementation\n       fft(x);\n       \n       // Compute the inverse transform by conjugating and scaling each element\n       const size_t N = x.size();\n       for (std::complex<double> &c : x) {\n           c = std::conj(c) / static_cast<double>(N);\n       }\n   }\n   ```\n\n4. Make sure the `fft` function is correctly implemented elsewhere in your code to be used by the `ifft` function.\n\nThis implementation follows the conventional definition of the inverse Fourier transform, applying the conjugate and scaling by `1/N` steps."}
{"algo": "fft", "spec": "06_fft_dft", "prompt": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {", "completion": "To compute the discrete Fourier transform (DFT) of the input values, you need to apply the formula for DFT. Here is a C++ function that calculates the DFT of the input vector `x` and stores the result in the `output` vector:\n\n```cpp\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <vector>\n\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n    size_t N = x.size();\n    for (size_t k = 0; k < N; ++k) {\n        output[k] = {0.0, 0.0};\n        for (size_t n = 0; n < N; ++n) {\n            double angle = 2.0 * M_PI * k * n / N;\n            output[k] += std::polar(x[n], -angle);\n        }\n    }\n}\n\nint main() {\n    std::vector<double> input = {1, 4, 9, 16};\n    std::vector<std::complex<double>> output(input.size());\n\n    dft(input, output);\n\n    // Output the result\n    for (size_t i = 0; i < output.size(); ++i) {\n        std::cout << output[i] << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis code defines the `dft` function to calculate the DFT of an input vector and stores the result in the `output` vector. You can then call the `dft` function with your input vector and the output vector to calculate the DFT and display the results."}
{"algo": "fft", "spec": "07_fft_fft_conjugate", "prompt": "/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {", "completion": "To compute the Fourier transform of the input vector `x` in-place and return the imaginary conjugate of each value, you can utilize a Fast Fourier Transform (FFT) algorithm. Here's an implementation of the `fftConjugate` function using the standard FFT algorithm with the aid of the C++ standard library for complex numbers:\n\n```cpp\n#include <vector>\n#include <complex>\n#include <cmath>\n\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\n    int n = x.size();\n    \n    if (n <= 1) {\n        return;\n    }\n    \n    std::vector<std::complex<double>> even(n/2), odd(n/2);\n    \n    for (int i = 0; i < n / 2; ++i) {\n        even[i] = x[i * 2];\n        odd[i] = x[i * 2 + 1];\n    }\n    \n    fftConjugate(even);\n    fftConjugate(odd);\n    \n    for (int k = 0; k < n / 2; ++k) {\n        std::complex<double> t = std::polar(1.0, -2 * M_PI * k / n) * odd[k];\n        x[k] = even[k] + t;\n        x[k + n / 2] = even[k] - t;\n    }\n}\n```\n\nThis function recursively applies the FFT algorithm to the even and odd halves of the input vector `x`, computes the Fourier transform, and calculates the complex conjugate of the imaginary component. The base case to stop recursion is when the input size is less than or equal to 1.\n\nYou can now call this `fftConjugate` function on your input vector to compute the Fourier transform and return the conjugate of each imaginary value. Make sure to populate the input vector `x` with your desired data before calling this function."}
{"algo": "fft", "spec": "08_fft_split_fft", "prompt": "/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {", "completion": "To compute the Fourier transform of the input signal `x`, we will use the Fast Fourier Transform algorithm provided by the C++ Standard Library (`std::fft`). Here is the continuation and completion of the code snippet provided:\n\n```cpp\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    int N = x.size();\n    std::vector<std::complex<double>> X(N);\n    \n    std::copy(x.begin(), x.end(), X.begin());\n    std::fft(X.data(), N);\n    \n    r.resize(N);\n    i.resize(N);\n    \n    for (int k = 0; k < N; ++k) {\n        r[k] = X[k].real();\n        i[k] = X[k].imag();\n    }\n}\n\nint main() {\n    std::vector<std::complex<double>> x = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n    std::vector<double> r, i;\n    \n    fft(x, r, i);\n    \n    std::cout << \"Real part: \";\n    for (auto val : r) {\n        std::cout << val << \" \";\n    }\n    \n    std::cout << \"\\nImaginary part: \";\n    for (auto val : i) {\n        std::cout << val << \" \";\n    }\n    \n    return 0;\n}\n```\n\nMake sure you include the necessary headers and libraries for `std::fft`. This code will read an input signal `x`, compute its Fourier Transform using the Fast Fourier Transform algorithm, and store the real and imaginary parts in the `r` and `i` vectors, respectively. The main function will demonstrate the usage with the provided example.\n\nFeel free to reach out if you need any further assistance or have any additional questions!"}
{"algo": "fft", "spec": "09_fft_fft_out_of_place", "prompt": "/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {", "completion": "To compute the Fourier Transform of the input vector x, you can use the FFT algorithm from a library like the Fastest Fourier Transform in the West (FFTW). Here is a basic example of how you can implement a function to compute the Fourier Transform using FFTW:\n\n```cpp\n#include <vector>\n#include <complex>\n#include <fftw3.h>\n\nvoid fft(const std::vector<std::complex<double>>& x, std::vector<std::complex<double>>& output) {\n    int N = x.size();\n    output.resize(N);\n\n    fftw_complex* in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n    fftw_complex* out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n\n    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    // Copy input data to fftw_complex array\n    for (int i = 0; i < N; ++i) {\n        in[i][0] = x[i].real();\n        in[i][1] = x[i].imag();\n    }\n\n    fftw_execute(p);\n\n    // Copy FFT result to output\n    for (int i = 0; i < N; ++i) {\n        output[i] = std::complex<double>(out[i][0], out[i][1]);\n    }\n\n    fftw_destroy_plan(p);\n    fftw_free(in);\n    fftw_free(out);\n}\n```\n\nIn this code snippet, we use the FFTW library to perform the Fourier Transform. You need to link your project against the FFTW library to use this code. The function takes the input vector x and computes its Fourier Transform, storing the result in the output vector.\n\nRemember to include the necessary header files and link against the FFTW library when using this code. Let me know if you need further assistance."}
{"algo": "geometry", "spec": "10_geometry_convex_hull", "prompt": "struct Point {\n   double x, y;\n};\n\n/* Find the set of points that defined the smallest convex polygon that contains all the points in the vector points. Store the result in `hull`.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: [{0, 3}, {4, 4}, {3, 1}, {0, 0}]\n*/\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {", "completion": "To implement the `convexHull` function, you can use the Gift Wrapping Algorithm (Jarvis March). Here's a step-by-step guide on how to implement it in C++:\n\n1. Define a helper function to find the orientation of three points (p, q, r):\n```cpp\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0; // Collinear\n    return (val > 0) ? 1 : 2; // Clockwise or counterclockwise\n}\n```\n\n2. Implement the `convexHull` function:\n```cpp\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {\n    int n = points.size();\n    if (n < 3) return;\n\n    hull.clear();\n\n    // Find the leftmost point\n    int leftmost = 0;\n    for (int i = 1; i < n; ++i) {\n        if (points[i].x < points[leftmost].x) {\n            leftmost = i;\n        }\n    }\n\n    int p = leftmost, q;\n    do {\n        hull.push_back(points[p]);\n        q = (p + 1) % n;\n        for (int i = 0; i < n; ++i) {\n            if (orientation(points[p], points[i], points[q]) == 2) {\n                q = i;\n            }\n        }\n        p = q;\n    } while (p != leftmost);\n}\n```\n\n3. You can then call this function with the vector of points to find the convex hull:\n```cpp\nstd::vector<Point> points = {{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}};\nstd::vector<Point> hull;\nconvexHull(points, hull);\n\n// Print the convex hull\nfor (const auto& point : hull) {\n    std::cout << \"{\" << point.x << \", \" << point.y << \"} \";\n}\n```\n\nThis implementation should find the smallest convex polygon that contains all the input points. Feel free to customize it further based on your requirements."}
{"algo": "geometry", "spec": "11_geometry_convex_hull_perimeter", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the perimeter of the smallest convex polygon that contains all the points in the vector points.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: 13.4477\n*/\ndouble convexHullPerimeter(std::vector<Point> const& points) {", "completion": "To calculate the perimeter of the smallest convex polygon that contains all the points in the vector, we can first compute the convex hull of the points and then find the sum of the distances between consecutive points along the convex hull.\n\nHere's a possible implementation of the `convexHullPerimeter` function using the Graham Scan algorithm to find the convex hull:\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\n// Helper function to calculate cross product\ndouble crossProduct(Point const& o, Point const& a, Point const& b) {\n    return (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);\n}\n\n// Function to compute convex hull\nstd::vector<Point> convexHull(std::vector<Point> points) {\n    int n = points.size();\n    if (n <= 3) {\n        return points;\n    }\n\n    std::sort(points.begin(), points.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    std::vector<Point> hull;\n    int k = 0;\n\n    // Lower Hull\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && crossProduct(hull[k - 2], hull[k - 1], points[i]) <= 0) {\n            hull.pop_back();\n            k--;\n        }\n        hull.push_back(points[i]);\n        k++;\n    }\n\n    // Upper Hull\n    for (int i = n - 2, t = k + 1; i >= 0; --i) {\n        while (k >= t && crossProduct(hull[k - 2], hull[k - 1], points[i]) <= 0) {\n            hull.pop_back();\n            k--;\n        }\n        hull.push_back(points[i]);\n        k++;\n    }\n\n    hull.pop_back(); // Last point is duplicated\n\n    return hull;\n}\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    std::vector<Point> convexHullPoints = convexHull(points);\n\n    double perimeter = 0;\n    for (size_t i = 0; i < convexHullPoints.size(); ++i) {\n        perimeter += distance(convexHullPoints[i], convexHullPoints[(i + 1) % convexHullPoints.size()]);\n    }\n\n    return perimeter;\n}\n```\n\nYou can call `convexHullPerimeter` with your input vector of points to get the perimeter of the smallest convex polygon that contains all the points."}
{"algo": "geometry", "spec": "12_geometry_smallest_triangle", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {", "completion": "To find the area of the smallest triangle that can be formed by any 3 points from a given set of points, you can generate all possible combinations of 3 points and calculate the area for each combination. Then, you can find the smallest area among these calculated areas. Here is the completion of the provided code:\n\n```cpp\n#include <vector>\n#include <algorithm> // for std::min_element\n#include <cmath>     // for std::abs\n#include <limits>    // for std::numeric_limits\n\nstruct Point {\n    double x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n    return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points */\ndouble smallestArea(std::vector<Point> const& points) {\n    double minArea = std::numeric_limits<double>::max();\n\n    // Generate all combinations of 3 points\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            for (size_t k = j + 1; k < points.size(); ++k) {\n                double area = triangleArea(points[i], points[j], points[k]);\n                minArea = std::min(area, minArea);\n            }\n        }\n    }\n\n    return minArea;\n}\n\nint main() {\n    // Example usage\n    std::vector<Point> points = {{0, 10}, {5, 5}, {1, 0}, {-1, 1}, {-10, 0}};\n    double result = smallestArea(points);\n    return result;\n}\n```\n\nIn this code, the `smallestArea` function calculates the area of all triangles formed by any 3 points, and stores the smallest area found. You can call this function with a vector of `Point` objects to get the area of the smallest triangle that can be formed."}
{"algo": "geometry", "spec": "13_geometry_closest_pair_2d", "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {", "completion": "To determine the closest pair of points in the given vector of points, we can calculate the distance between all possible pairs of points and then find the pair with the smallest distance. Here's how you can implement the `closestPair` function:\n\n```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\ndouble closestPair(std::vector<Point> const& points) {\n    double minDistance = std::numeric_limits<double>::max();\n\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            minDistance = std::min(minDistance, distance(points[i], points[j]));\n        }\n    }\n\n    return minDistance;\n}\n```\n\nYou can then call this function with a vector of `Point` objects to get the distance between the closest pair of points."}
{"algo": "geometry", "spec": "14_geometry_closest_pair_1d", "prompt": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {", "completion": "To find the distance between the closest two elements in the vector `x`, you can do the following:\n\n1. Sort the elements in the vector `x` in ascending order.\n2. Initialize a variable to keep track of the minimum distance found so far.\n3. Iterate through the sorted vector, calculating the distance between adjacent elements and updating the minimum distance accordingly.\n4. Return the minimum distance found.\n\nHere's how you can implement the `closestPair` function:\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\ndouble distance(double x1, double x2) {\n    return std::abs(x1 - x2);\n}\n\ndouble closestPair(std::vector<double> const& x) {\n    std::vector<double> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n\n    double min_distance = std::numeric_limits<double>::max();\n\n    for (size_t i = 0; i < sorted_x.size() - 1; ++i) {\n        double curr_distance = distance(sorted_x[i], sorted_x[i + 1]);\n        min_distance = std::min(min_distance, curr_distance);\n    }\n\n    return min_distance;\n}\n\nint main() {\n    std::vector<double> x = {7, 3, 9, 12, 31, 1};\n    double result = closestPair(x);\n    return 0;\n}\n```\n\nThis code snippet sets up the function `closestPair` to find the closest pair of elements in the input vector `x` and returns the minimum distance. You can customize this function further or expand upon it based on your requirements."}
{"algo": "graph", "spec": "15_graph_edge_count", "prompt": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {", "completion": "To count the number of edges in a directed graph represented by an adjacency matrix, we need to iterate over each element in the lower triangular part of the matrix (excluding the diagonal), as each entry in the adjacency matrix represents a possible edge in the graph.\n\nThe following C++ function accomplishes this:\n\n```cpp\n#include <vector>\n\nint edgeCount(std::vector<int> const& A, size_t N) {\n    int count = 0;\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (A[i * N + j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<std::vector<int>> input = {{0, 0, 0, 1}, {0, 0, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}};\n    size_t N = input.size();\n\n    std::vector<int> flattened_input;\n     for (const auto& row : input) {\n        flattened_input.insert(flattened_input.end(), row.begin(), row.end());\n    }\n\n    int result = edgeCount(flattened_input, N);\n    std::cout << \"Number of edges: \" << result << std::endl;\n\n    return 0;\n}\n```\n\nIn this code:\n- The `edgeCount` function takes a flattened one-dimensional adjacency matrix `A` and the size of the matrix `N`.\n- It iterates over the lower triangular part of the matrix except for the diagonal and counts the number of edges.\n- Finally, the `main` function initializes the input matrix, flattens it, and calls `edgeCount` to calculate the number of edges. \n\nYou can run this code and input the adjacency matrix to get the count of edges in the directed graph."}
{"algo": "graph", "spec": "16_graph_largest_component", "prompt": "/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {", "completion": "To find the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A, you can use graph traversal algorithms like DFS (Depth First Search) or BFS (Breadth First Search). Here is a sample code snippet in C++ using DFS to achieve this:\n\n```cpp\n#include <vector>\n#include <stack>\n#include <unordered_set>\n\nint DFS(std::vector<int> const& A, size_t N, int start, std::unordered_set<int>& visited) {\n    int count = 0;\n    \n    std::stack<int> stack;\n    stack.push(start);\n    \n    while (!stack.empty()) {\n        int current = stack.top();\n        stack.pop();\n        \n        if (visited.count(current) == 0) {\n            visited.insert(current);\n            count++;\n            \n            for (int i = 0; i < N; ++i) {\n                if (A[current * N + i] == 1 && visited.count(i) == 0) {\n                    stack.push(i);\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nint largestComponent(std::vector<int> const& A, size_t N) {\n    int maxComponentSize = 0;\n    std::unordered_set<int> visited;\n    \n    for (int i = 0; i < N; ++i) {\n        if (visited.count(i) == 0) {\n            int componentSize = DFS(A, N, i, visited);\n            if (componentSize > maxComponentSize) {\n                maxComponentSize = componentSize;\n            }\n        }\n    }\n    \n    return maxComponentSize;\n}\n```\n\nYou can call the `largestComponent` function with the adjacency matrix `A` and the size `N` to get the number of vertices in the largest component of the graph."}
{"algo": "graph", "spec": "17_graph_highest_degree", "prompt": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {", "completion": "To find the highest node degree in the undirected graph represented by the adjacency matrix A, you can count the number of connections each node has.\n\nHere's how you can implement the `maxDegree` function:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nint maxDegree(std::vector<int> const& A, size_t N) {\n    int maxDegree = 0;\n    \n    for (size_t i = 0; i < N; ++i) {\n        int degree = 0;\n        for (size_t j = 0; j < N; ++j) {\n            if (A[i * N + j] == 1) {\n                ++degree;\n            }\n        }\n        maxDegree = std::max(maxDegree, degree);\n    }\n    \n    return maxDegree;\n}\n```\n\nYou can call this function with the adjacency matrix (A) and the size of the matrix (N) to compute the highest node degree in the graph."}
{"algo": "graph", "spec": "18_graph_count_components", "prompt": "/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {", "completion": "To count the number of connected components in the undirected graph using the adjacency matrix provided, you can perform a depth-first search (DFS) on the graph.\n\nHere is the implementation of the `componentCount` function:\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\nvoid dfs(const std::vector<int>& A, std::unordered_set<int>& visited, int current, int N) {\n    visited.insert(current);\n    for (int i = 0; i < N; ++i) {\n        if (A[current * N + i] == 1 && visited.find(i) == visited.end()) {\n            dfs(A, visited, i, N);\n        }\n    }\n}\n\nint componentCount(const std::vector<int>& A, size_t N) {\n    int count = 0;\n    std::unordered_set<int> visited;\n\n    for (int i = 0; i < N; ++i) {\n        if (visited.find(i) == visited.end()) {\n            dfs(A, visited, i, N);\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n\nIn this implementation:\n- The `dfs` function performs a depth-first search starting from a given node.\n- The main `componentCount` function iterates through all nodes, initiating a DFS from each unvisited node and increments the count for each unique connected component found.\n\nYou can call this function by passing the flattened adjacency matrix `A` and the size `N` as arguments to get the number of connected components in the graph."}
{"algo": "graph", "spec": "19_graph_shortest_path", "prompt": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {", "completion": "To calculate the length of the shortest path from the source to the destination in the undirected graph defined by the adjacency matrix `A`, you can use breadth-first search (BFS). Here is some code that implements this logic:\n\n```cpp\n#include <vector>\n#include <queue>\n\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n    std::vector<bool> visited(N, false);\n    std::queue<std::pair<int, int>> q; // Pair of node and distance from source\n\n    q.push({source, 0});\n    visited[source] = true;\n\n    while (!q.empty()) {\n        int node = q.front().first;\n        int dist = q.front().second;\n        q.pop();\n\n        if (node == dest) {\n            return dist;\n        }\n\n        for (int i = 0; i < N; ++i) {\n            if (A[node * N + i] && !visited[i]) {\n                q.push({i, dist + 1});\n                visited[i] = true;\n            }\n        }\n    }\n\n    return -1; // If source and destination are not connected\n}\n```\n\nYou can call this function with the adjacency matrix `A`, its size `N`, source node, and destination node to get the length of the shortest path between them."}
{"algo": "histogram", "spec": "20_histogram_pixel_histogram", "prompt": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {", "completion": "To calculate the number of pixels in the image with each grayscale intensity, we need to iterate through the image vector and count the occurrences of each intensity level. Here is a possible implementation of the `pixelCounts` function:\n\n```cpp\n#include <vector>\n#include <array>\n\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256>& bins) {\n    // Initialize the bins to zeros\n    bins.fill(0);\n\n    // Iterate through the image vector\n    for (int intensity : image) {\n        // Increment the count for the corresponding intensity level\n        bins[intensity]++;\n    }\n}\n```\n\nThis function takes the `image` vector containing grayscale intensity values and populates the `bins` array with the count of pixels for each intensity level from 0 to 255.\n\nYou can call this function with your example input as follows:\n\n```cpp\nint main() {\n    std::vector<int> image = {2, 116, 201, 11, 92, 92, 201, 4, 2};\n    std::array<size_t, 256> bins;\n\n    pixelCounts(image, bins);\n\n    // Output the results\n    for (int i = 0; i < bins.size(); i++) {\n        std::cout << \"Intensity \" << i << \": \" << bins[i] << \" pixels\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\nDon't forget to include the necessary headers and the `iostream` library for printing the results."}
{"algo": "histogram", "spec": "21_histogram_bin_0-100", "prompt": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {", "completion": "To accomplish this task, we can iterate through the vector `x` and increment the corresponding bin count based on the value in the vector. Here's a possible implementation for the `binsBy10Count` function:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <array>\n\nvoid binsBy10Count(const std::vector<double> &x, std::array<size_t, 10> &bins) {\n    for (double value : x) {\n        size_t bin = static_cast<size_t>(value) / 10;\n        if (bin < bins.size()) {\n            ++bins[bin];\n        }\n    }\n}\n\nint main() {\n    std::vector<double> input = {7, 32, 95, 12, 39, 32, 11, 71, 70, 66};\n    std::array<size_t, 10> bins = {0};\n\n    binsBy10Count(input, bins);\n\n    for (size_t i = 0; i < bins.size(); ++i) {\n        std::cout << \"Count in bin [\" << i * 10 << \", \" << (i + 1) * 10 << \"): \" << bins[i] << std::endl;\n    }\n\n    return 0;\n}\n```\n\nIn this implementation:\n- We iterate over the values in the input vector `x`.\n- We calculate the bin for each value by dividing it by 10 and truncating the decimal part.\n- We increment the count in the corresponding bin if it is within the array bounds.\n- Finally, we print out the counts for each bin.\n\nYou can run this code snippet in a C++ environment to see the desired output based on the sample input provided in the comments."}
{"algo": "histogram", "spec": "22_histogram_count_quadrants", "prompt": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {", "completion": "To implement the `countQuadrants` function, we need to iterate over each point in the input vector, determine which quadrant it falls into based on its coordinates, and increment the corresponding count in the `bins` array. Here's how you can implement this function:\n\n```cpp\n#include <vector>\n#include <array>\n\nstruct Point {\n    double x, y;\n};\n\nvoid countQuadrants(const std::vector<Point> &points, std::array<size_t, 4> &bins) {\n    // Initialize the bins array with zeros\n    bins.fill(0);\n\n    // Iterate over each point in the vector\n    for(const Point &point : points) {\n        if (point.x > 0 && point.y > 0) {\n            // Point in first quadrant\n            bins[0]++;\n        } else if (point.x < 0 && point.y > 0) {\n            // Point in second quadrant\n            bins[1]++;\n        } else if (point.x < 0 && point.y < 0) {\n            // Point in third quadrant\n            bins[2]++;\n        } else if (point.x > 0 && point.y < 0) {\n            // Point in fourth quadrant\n            bins[3]++;\n        }\n    }\n}\n\nint main() {\n    std::vector<Point> points = {{1.5, 0.1}, {-3, 1.1}, {5, 9}, {1.5, -1}, {3, -7}, {0.1, 2}};\n    std::array<size_t, 4> bins = {0, 0, 0, 0};\n\n    countQuadrants(points, bins);\n\n    // Display the counts in each quadrant\n    for(size_t i = 0; i < bins.size(); ++i) {\n        std::cout << \"Quadrant \" << (i+1) << \" count: \" << bins[i] << std::endl;\n    }\n\n    return 0;\n}\n```\n\nIn this code snippet, the `countQuadrants` function takes the vector of points and the bins array by reference. Inside the function, we iterate through each point and determine its quadrant based on the sign of its x and y coordinates. We then update the corresponding count in the `bins` array. Finally, in the `main` function, we demonstrate how to use this function with a sample set of points."}
{"algo": "histogram", "spec": "23_histogram_first_letter_counts", "prompt": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {", "completion": "Here is the code implementation for the `firstLetterCounts` function as described:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <array>\n\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    for (const std::string& str : s) {\n        if (!str.empty()) {\n            char firstChar = str[0];\n            if (firstChar >= 'a' && firstChar <= 'z') {\n                bins[firstChar - 'a']++;\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> input = {\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"};\n    std::array<size_t, 26> bins = {0};\n\n    firstLetterCounts(input, bins);\n\n    // Output the result\n    std::cout << \"[\";\n    for (size_t count : bins) {\n        std::cout << count << \", \";\n    }\n    std::cout << \"]\" << std::endl;\n\n    return 0;\n}\n```\n\nThis code will count the number of strings in the vector `s` that start with each letter of the alphabet, considering only lowercase letters. The result will be stored in the `bins` array. The example input you provided is used in the `main` function to demonstrate the functionality."}
{"algo": "histogram", "spec": "24_histogram_count_quartile", "prompt": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {", "completion": "To implement the `countQuartiles` function, you can follow these steps:\n\n1. Initialize counters for each quartile range `[0, 0.25)`, `[0.25, 0.5)`, `[0.5, 0.75)`, and `[0.75, 1)` as 0.\n2. Iterate over each double in the input vector `x`.\n3. For each double, check if its fractional part falls within the specified quartile range using `std::modf` function.\n4. Increment the corresponding counter in the `bins` array based on the quartile range.\n5. Finally, the `bins` array will contain the counts of doubles in each quartile range.\n\nHere's a possible implementation of the `countQuartiles` function:\n\n```cpp\n#include <vector>\n#include <array>\n#include <cmath>\n\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    for (double num : x) {\n        double frac;\n        double intPart = std::modf(num, &frac);\n        \n        if (frac < 0.25) {\n            ++bins[0];\n        } else if (frac < 0.5) {\n            ++bins[1];\n        } else if (frac < 0.75) {\n            ++bins[2];\n        } else {\n            ++bins[3];\n        }\n    }\n}\n```\n\nYou can now use this function to count the number of doubles in the specified quartile ranges as described in the examples you provided."}
{"algo": "reduce", "spec": "25_reduce_xor", "prompt": "/* Return the logical XOR reduction of the vector of bools x.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {", "completion": "To implement the logical XOR reduction function, you can iterate over the vector of bools and use XOR operations to calculate the result. Here's a possible implementation in C++:\n\n```cpp\n#include <vector>\n\nbool reduceLogicalXOR(const std::vector<bool>& x) {\n    bool result = false;\n    for (bool b : x) {\n        result ^= b;\n    }\n    return result;\n}\n```\n\nThis function iterates over the input vector `x`, sequentially performing XOR operations with the current value and the result. The final result will be the logical XOR reduction of all the elements in the vector.\n\nYou can call this function with your example input, `[false, false, false, true]`, to get the expected output of `true`."}
{"algo": "reduce", "spec": "26_reduce_product_of_inverses", "prompt": "/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {", "completion": "Here is how you can implement the function to achieve the desired result:\n\n```cpp\ndouble productWithInverses(std::vector<double> const& x) {\n    double product = 1.0;\n    for (size_t i = 0; i < x.size(); i++) {\n        if (i % 2 == 0) {\n            product *= x[i];\n        } else {\n            product /= x[i];\n        }\n    }\n    return product;\n}\n```\n\nThis function iterates through the vector elements and multiplies each even indexed element with the product, while dividing each odd indexed element by the product. The final product is then returned."}
{"algo": "reduce", "spec": "27_reduce_average", "prompt": "/* Return the average of the vector x.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {", "completion": "To calculate the average of the given vector x, you can sum all elements and then divide by the number of elements in the vector. Here is a possible implementation for the `average` function:\n\n```cpp\n#include <vector>\n\ndouble average(std::vector<double> const& x) {\n    if (x.empty()) {\n        return 0.0; // Handling the case where the vector is empty\n    }\n\n    double sum = 0.0;\n    for (auto const& elem : x) {\n        sum += elem;\n    }\n\n    return sum / x.size();\n}\n```\n\nYou can use this function by passing your vector as an argument, and it will return the average of the vector elements. Let me know if you need any more help."}
{"algo": "reduce", "spec": "28_reduce_smallest_odd_number", "prompt": "/* Return the value of the smallest odd number in the vector x.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {", "completion": "To accomplish this task, you can iterate over the vector elements and keep track of the smallest odd number encountered so far. Here's how you can implement the `smallestOdd` function:\n\n```cpp\n#include <vector>\n\nint smallestOdd(std::vector<int> const& x) {\n    int smallestOdd = -1; // Initialize with a value that indicates no odd number found yet\n\n    for (int num : x) {\n        if (num % 2 != 0 && (smallestOdd == -1 || num < smallestOdd)) {\n            smallestOdd = num;\n        }\n    }\n\n    return smallestOdd;\n}\n```\n\nThis function loops through each element in the input vector `x`. It checks if the current number is odd and smaller than the previously found smallest odd number. If so, it updates the `smallestOdd` variable. Finally, it returns the smallest odd number found or -1 if no odd number was present in the input vector.\n\nYou can use this function with the provided examples to get the smallest odd number in a vector."}
{"algo": "reduce", "spec": "29_reduce_sum_of_min_of_pairs", "prompt": "/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {", "completion": "To calculate the sum of the minimum values at each index from two input vectors, you can use the following C++ function:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n    double sum = 0.0;\n    size_t size = std::min(x.size(), y.size());\n\n    for (size_t i = 0; i < size; ++i) {\n        sum += std::min(x[i], y[i]);\n    }\n\n    return sum;\n}\n```\n\nThis function iterates over both input vectors using index `i` and calculates the sum of the minimum values at each index. It uses `std::min` to compare and select the minimum value between `x[i]` and `y[i]`.\n\nYou can call this function with your example input to get the output:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<double> x = {3, 4, 0, 2, 3};\n    std::vector<double> y = {2, 5, 3, 1, 7};\n\n    double result = sumOfMinimumElements(x, y);\n\n    std::cout << \"Sum of minimum elements: \" << result << std::endl;\n\n    return 0;\n}\n```\n\nWhen you run this code with the provided input vectors, it will output `Sum of minimum elements: 10`."}
{"algo": "scan", "spec": "30_scan_prefix_sum", "prompt": "/* Compute the prefix sum of the vector x into output.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {", "completion": "To compute the prefix sum of the vector `x` into the `output` vector, you can use the following function implementation:\n\n```cpp\n#include <vector>\n\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n    if (x.empty()) {\n        return;\n    }\n\n    output.resize(x.size());\n    output[0] = x[0];\n    \n    for (size_t i = 1; i < x.size(); ++i) {\n        output[i] = output[i - 1] + x[i];\n    }\n}\n```\n\nYou can call this function with the input vector `x` and an empty vector for the output as follows:\n\n```cpp\nstd::vector<double> x = {1, 7, 4, 6, 6, 2};\nstd::vector<double> output;\n\nprefixSum(x, output);\n\n// Print the computed prefix sum\nfor (double value : output) {\n    std::cout << value << \" \";\n}\n```\n\nThis code will compute the prefix sum of the input vector `x` and store the result in the `output` vector."}
{"algo": "scan", "spec": "31_scan_scan_with_min_function", "prompt": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {", "completion": "Here is a possible implementation of the `partialMinimums` function:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nvoid partialMinimums(std::vector<float> &x) {\n    if (x.empty()) {\n        return; // Nothing to do for an empty vector\n    }\n\n    float min_val = x[0]; // Initialize min_val with the first element\n    for (size_t i = 0; i < x.size(); ++i) {\n        min_val = std::min(min_val, x[i]); // Update min_val with the minimum value found so far\n        x[i] = min_val; // Replace the i-th element with the minimum value found up to the i-th index\n    }\n}\n```\n\nYou can call this function with your input vector to modify it as described in your examples."}
{"algo": "scan", "spec": "32_scan_sum_of_prefix_sum_array", "prompt": "/* Compute the prefix sum array of the vector x and return its sum.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {", "completion": "To compute the sum of the prefix sum array of a given vector `x`, you can iterate through the vector and calculate the prefix sum at each index. Here's the implementation to achieve this:\n\n```cpp\n#include <vector>\n\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n    double sum = 0;\n    double prefixSum = 0;\n\n    for (double num : x) {\n        prefixSum += num;\n        sum += prefixSum;\n    }\n\n    return sum;\n}\n\nint main() {\n    std::vector<double> input = {-7, 2, 1, 9, 4, 8};\n    double result = sumOfPrefixSum(input);\n    std::cout << \"Sum of Prefix Sums: \" << result << std::endl;\n\n    return 0;\n}\n```\n\nIn this code snippet, the `sumOfPrefixSum` function calculates the sum of the prefix sum array by maintaining the running sum of prefix sums as it iterates through the input vector `x`.\n\nWhen you run this code with the provided example input `[-7, 2, 1, 9, 4, 8]`, it should output `15` as expected."}
{"algo": "scan", "spec": "33_scan_reverse_prefix_sum", "prompt": "/* Compute the reverse prefix sum of the vector x into output.\n   Examples:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [2, 8, 14, 18, 25, 26]\n\n   input: [3, 3, 7, 1, -2]\n   output: [-2, -1, 6, 9, 12]\n*/\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {", "completion": "To compute the reverse prefix sum of the vector `x` into the `output`, you can iterate through the elements of `x` in reverse order and calculate the running sum starting from the last element. Here's how you can implement the `reversePrefixSum` function:\n\n```cpp\n#include <vector>\n\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    if (x.empty()) {\n        output.clear();\n        return;\n    }\n\n    output.resize(x.size());\n    int sum = 0;\n    \n    for (int i = x.size() - 1; i >= 0; --i) {\n        sum += x[i];\n        output[i] = sum;\n    }\n}\n```\n\nYou can now call this function with an input vector and an empty output vector to store the reverse prefix sum values. For example:\n\n```cpp\nint main() {\n    std::vector<int> input1 = {1, 7, 4, 6, 6, 2};\n    std::vector<int> output1;\n    reversePrefixSum(input1, output1);\n\n    // Output the result\n    for (int val : output1) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n\nThis implementation calculates the reverse prefix sum of the input vector and stores the result in the output vector provided as a reference argument."}
{"algo": "scan", "spec": "34_scan_largest_contiguous_subarray_sum", "prompt": "/* Return the largest sum of any contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4] then [4, \u22121, 2, 1] is the contiguous\n   subarray with the largest sum of 6.\n   Example:\n\n   input: [\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4]\n   output: 6\n*/\nint maximumSubarray(std::vector<int> const& x) {", "completion": "To solve this problem, you can use the Kadane's algorithm. Here is an implementation of the `maximumSubarray` function:\n\n```cpp\n#include <vector>\n#include <algorithm> // for std::max\n\nint maximumSubarray(std::vector<int> const& x) {\n    int max_sum = x[0];\n    int current_sum = x[0];\n\n    for (size_t i = 1; i < x.size(); ++i) {\n        current_sum = std::max(x[i], current_sum + x[i]);\n        max_sum = std::max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n\n// Example usage:\nint main() {\n    std::vector<int> x = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    int result = maximumSubarray(x);\n    // Output the result\n    return 0;\n}\n```\n\nYou can call the `maximumSubarray` function with the input vector to get the maximum sum of any contiguous subarray."}
{"algo": "search", "spec": "35_search_search_for_last_struct_by_key", "prompt": "struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {", "completion": "To implement the `findLastShortBook` function, you can iterate through the given vector of `Book` objects in reverse order and check if the `pages` of each book is less than 100. If it is, you return the index of that book. Here's the complete implementation for the `findLastShortBook` function:\n\n```cpp\n#include <vector>\n#include <string>\n\nstruct Book {\n    std::string title;\n    int pages;\n};\n\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    for (size_t i = books.size(); i > 0; --i) {\n        if (books[i - 1].pages < 100) {\n            return i - 1;\n        }\n    }\n    // If no book with pages < 100 is found, return an appropriate value (e.g., books.size()).\n    return books.size();\n}\n\nint main() {\n    std::vector<Book> books = {\n        {\"Green Eggs and Ham\", 72},\n        {\"gulliver's travels\", 362},\n        {\"Stories of Your Life\", 54},\n        {\"Hamilton\", 818}\n    };\n\n    size_t index = findLastShortBook(books);\n    if (index < books.size()) {\n        std::cout << \"Index of the last book with pages < 100: \" << index << std::endl;\n    } else {\n        std::cout << \"No book with pages < 100 found in the provided list.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\nYou can call this function in your program with the provided example input to get the desired output."}
{"algo": "search", "spec": "36_search_check_if_array_contains_value", "prompt": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {", "completion": "To implement the `contains` function that checks whether a vector contains a specific value, you can follow the example below:\n\n```cpp\n#include <vector>\n\nbool contains(std::vector<int> const& x, int target) {\n    for (int value : x) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nYou can use this function by providing a vector of integers `x` and the target value you want to find. The function will return true if the value is found in the vector and false otherwise. Let me know if you need any additional help or further clarification."}
{"algo": "search", "spec": "37_search_find_the_closest_number_to_pi", "prompt": "/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {", "completion": "Here is a possible implementation for the `findClosestToPi` function:\n\n```cpp\n#include <vector>\n#include <cmath>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    double closestDiff = std::abs(x[0] - M_PI);\n    size_t closestIndex = 0;\n\n    for (size_t i = 1; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < closestDiff) {\n            closestDiff = diff;\n            closestIndex = i;\n        }\n    }\n\n    return closestIndex;\n}\n```\n\nYou can now call this function with your input vector to find the index of the element closest to the math constant PI."}
{"algo": "search", "spec": "38_search_find_the_first_even_number", "prompt": "/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {", "completion": "To find the index of the first even number in the vector, you can iterate over the elements and check if each element is even. Here's the implementation for the `findFirstEven` function:\n\n```cpp\n#include <vector>\n\nsize_t findFirstEven(std::vector<int> const& x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) { // Check if current element is even\n            return i; // Return the index if found\n        }\n    }\n    return -1; // Return -1 if no even number is found\n}\n```\n\nYou can use this function to find the index of the first even number in a vector as shown in the examples you provided."}
{"algo": "search", "spec": "39_search_xor_contains", "prompt": "/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {", "completion": "Here is the complete implementation of the `xorContains` function based on the provided comments and examples:\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool inX = std::find(x.begin(), x.end(), val) != x.end();\n    bool inY = std::find(y.begin(), y.end(), val) != y.end();\n\n    // Return true if val is only in one of the vectors x or y\n    // Return false if it is in both or neither\n    return (inX && !inY) || (!inX && inY);\n}\n\n// Test your function with the provided examples\nint main() {\n    std::vector<int> x = {1, 8, 4, 3, 2};\n    std::vector<int> y = {3, 4, 4, 1, 1, 7};\n\n    // Test case 1\n    int val1 = 7;\n    bool result1 = xorContains(x, y, val1);\n    std::cout << \"Is \" << val1 << \" found in only one vector? \" << std::boolalpha << result1 << std::endl;\n\n    // Test case 2\n    int val2 = 1;\n    bool result2 = xorContains(x, y, val2);\n    std::cout << \"Is \" << val2 << \" found in only one vector? \" << std::boolalpha << result2 << std::endl;\n\n    return 0;\n}\n```\n\nThis implementation uses `std::find` to check if the value `val` is present in vectors `x` and `y`. The `xorContains` function then returns true if the value is only in one vector and false if it is in both vectors or in neither."}
{"algo": "sort", "spec": "40_sort_sort_an_array_of_complex_numbers_by_magnitude", "prompt": "/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {", "completion": "Here is a possible implementation for sorting a vector of complex numbers by their magnitude in ascending order:\n\n```cpp\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nbool compareMagnitude(const std::complex<double> &a, const std::complex<double> &b) {\n    return std::abs(a) < std::abs(b);\n}\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    std::sort(x.begin(), x.end(), compareMagnitude);\n}\n```\n\nYou can use the `sortComplexByMagnitude` function to sort the vector of complex numbers by magnitude in ascending order. The `compareMagnitude` function is used as the custom comparison function for sorting based on magnitude."}
{"algo": "sort", "spec": "41_sort_k-th_smallest_element", "prompt": "/* Find the k-th smallest element of the vector x.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {", "completion": "To find the k-th smallest element of the vector x, you can first sort the elements in non-decreasing order and then return the k-th element from the sorted vector.\n\nHere's the code snippet to achieve this:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nint findKthSmallest(std::vector<int> const& x, int k) {\n    std::vector<int> sortedX = x;\n    std::sort(sortedX.begin(), sortedX.end());\n\n    // Return the k-th smallest element (k-1 index in zero-based indexing)\n    return sortedX[k - 1];\n}\n\n// Example usage\n// int main() {\n//     std::vector<int> x = {1, 7, 6, 0, 2, 2, 10, 6};\n//     int k = 4;\n//     int result = findKthSmallest(x, k);\n//     // Output should be 6\n//     return 0;\n// }\n```\n\nYou can uncomment the `main` function and the example usage section to test the `findKthSmallest` function with the provided example.\n\nFeel free to let me know if you need further assistance or have any more questions."}
{"algo": "sort", "spec": "42_sort_sorted_ranks", "prompt": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {", "completion": "To implement the `ranks` function, you can follow these steps:\n\n1. Create a copy of the original vector `x` and sort it in increasing order.\n2. Initialize an empty map to store the index of each element in the sorted vector.\n3. Iterate through the sorted vector and populate the map with the element as the key and its index as the value.\n4. To get the ranks, iterate through the original vector `x` and for each element, retrieve its index from the map and store it in the `ranks` vector.\n\nHere is the implementation of the `ranks` function with comments to explain each step:\n\n```cpp\n#include <vector>\n#include <map>\n#include <algorithm>\n\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n    // Create a copy of the original vector and sort it in increasing order\n    std::vector<float> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n\n    // Initialize a map to store index of each element in the sorted vector\n    std::map<float, size_t> index_map;\n    for (size_t i = 0; i < sorted_x.size(); ++i) {\n        index_map[sorted_x[i]] = i;\n    }\n\n    // Get ranks for elements in the original vector\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks.push_back(index_map[x[i]]);\n    }\n}\n```\n\nYou can now call this `ranks` function with your input vector and an empty vector `ranks` to store the results."}
{"algo": "sort", "spec": "43_sort_sort_an_array_of_structs_by_key", "prompt": "struct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {", "completion": "To sort the vector of `Result` structs by start time in ascending order, you can use the `std::sort` function from the `<algorithm>` header in C++.\n\nHere's how you can implement the `sortByStartTime` function:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nstruct Result {\n    int startTime, duration;\n    float value;\n};\n\nbool compareByStartTime(const Result& a, const Result& b) {\n    return a.startTime < b.startTime;\n}\n\nvoid sortByStartTime(std::vector<Result> &results) {\n    std::sort(results.begin(), results.end(), compareByStartTime);\n}\n```\n\nIn this implementation:\n- The `compareByStartTime` function defines the comparison logic based on the start time of the `Result` structs.\n- The `std::sort` function is used with a custom comparison function `compareByStartTime` to sort the vector `results` in ascending order based on the start time.\n\nYou can now call the `sortByStartTime` function with your vector of `Result` structs to sort them by start time."}
{"algo": "sort", "spec": "44_sort_sort_non-zero_elements", "prompt": "/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place.\n   Example:\n\n\t input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {", "completion": "Here's an implementation that sorts the vector `x` in ascending order, keeping the zero-valued elements in their original positions.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nvoid sortIgnoreZero(std::vector<int> &x) {\n    std::vector<int> nonZeroElements;\n    std::vector<int> zeroIndices;\n\n    // Separate non-zero elements and zero indices\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            nonZeroElements.push_back(x[i]);\n        } else {\n            zeroIndices.push_back(i);\n        }\n    }\n\n    // Sort non-zero elements\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n\n    // Place sorted non-zero elements back into the vector\n    size_t nonZeroIndex = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (std::find(zeroIndices.begin(), zeroIndices.end(), i) == zeroIndices.end()) {\n            x[i] = nonZeroElements[nonZeroIndex];\n            ++nonZeroIndex;\n        }\n    }\n}\n```\n\nYou can call this function with your input vector to achieve the desired result."}
{"algo": "sparse_la", "spec": "45_sparse_la_sparse_solve", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Solve the sparse linear system Ax=b for x.\n   A is a sparse NxN matrix in COO format. x and b are dense vectors with N elements.\n   Example:\n   \n   input: A=[{0,0,1}, {0,1,1}, {1,1,-2}] b=[1,4]\n   output: x=[3,-2]\n*/\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {", "completion": "To solve the sparse linear system Ax=b for x using the COO format, you can first construct the corresponding sparse matrix from the provided COO elements in vector A. Once you have the sparse matrix, you can solve the system using the appropriate method. Here's a sample code snippet showing how you can achieve this:\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <cstddef>\n#include <Eigen/Sparse>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double>& x, size_t N) {\n    // Build a sparse matrix from COO format\n    Eigen::SparseMatrix<double> sparseA(N, N);\n    std::vector<Eigen::Triplet<double>> tripletList;\n    tripletList.reserve(A.size());\n    for (const auto& element : A) {\n        tripletList.emplace_back(element.row, element.column, element.value);\n    }\n    sparseA.setFromTriplets(tripletList.begin(), tripletList.end());\n\n    // Solve the linear system Ax=b\n    Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;\n    solver.compute(sparseA);\n\n    if (solver.info() != Eigen::Success) {\n        std::cerr << \"Error during decomposition of the sparse matrix.\" << std::endl;\n        return;\n    }\n\n    Eigen::Map<Eigen::VectorXd> bVec(b.data(), N);\n    Eigen::Map<Eigen::VectorXd> xVec(x.data(), N);\n    xVec = solver.solve(bVec);\n\n    std::cout << \"Solution x: \" << xVec.transpose() << std::endl;\n}\n\nint main() {\n    // Example COO format input {0,0,1}, {0,1,1}, {1,1,-2}\n    std::vector<COOElement> A = {{0, 0, 1}, {0, 1, 1}, {1, 1, -2}};\n    std::vector<double> b = {1, 4};\n\n    size_t N = 2; // Size of the square matrix A\n    std::vector<double> x(N);\n\n    solveLinearSystem(A, b, x, N);\n\n    return 0;\n}\n```\n\nIn this code snippet, we use Eigen library to work with sparse matrices and solve the linear system. The `solveLinearSystem` function constructs the sparse matrix A and uses Eigen's `SparseLU` solver to solve the system Ax=b. Make sure to include the Eigen library in your project for this code to work.\n\nYou can use this code as a reference to implement the `solveLinearSystem` function for your specific needs and adapt it as necessary. If you have any questions or need further clarification, feel free to ask!"}
{"algo": "sparse_la", "spec": "46_sparse_la_spmm", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {", "completion": "Here is the implementation of the `spmm` function that computes the matrix multiplication Y = AX. The function loops through the elements of matrices A and X to perform the multiplication and accumulates the results in the output matrix Y.\n\n```cpp\n#include <vector>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n    // Initialize the output matrix Y with zeros\n    Y.resize(M * N, 0.0);\n\n    // Perform matrix multiplication\n    for (const auto& elemA : A) {\n        for (const auto& elemX : X) {\n            if (elemA.column == elemX.row) {\n                Y[elemA.row * N + elemX.column] += elemA.value * elemX.value;\n            }\n        }\n    }\n}\n\nint main() {\n    // Example input matrices A and X\n    std::vector<COOElement> A = {{0, 0, -2}, {0, 1, 1}, {1, 1, -1}};\n    std::vector<COOElement> X = {{0, 1, 2}, {1, 0, -1}};\n    \n    // Define the dimensions of the matrices\n    size_t M = 2; // Rows of A, Rows of Y\n    size_t K = 2; // Columns of A, Rows of X\n    size_t N = 2; // Columns of X, Columns of Y\n\n    // Initialize the output matrix Y\n    std::vector<double> Y;\n    \n    // Perform matrix multiplication\n    spmm(A, X, Y, M, K, N);\n\n    // Output the result matrix Y\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            std::cout << Y[i * N + j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis code defines the `spmm` function to perform the matrix multiplication and provides an example usage in the `main` function. You can test it with different matrices A and X to verify the correctness of the multiplication. Let me know if you need further assistance!"}
{"algo": "sparse_la", "spec": "47_sparse_la_spmv", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {", "completion": "This function performs the Sparse Matrix-Vector Multiplication (SPMV) operation. It computes y = alpha*A*x + beta*y, where A is a sparse matrix in the Coordinate List (COO) format, alpha and beta are scalars, x and y are vectors.\n\nThe function takes the following parameters:\n- `alpha`: Scalar multiplier for the matrix-vector product.\n- `A`: Vector of COOElement representing the sparse matrix A.\n- `x`: Vector representing the input vector x.\n- `beta`: Scalar multiplier for the vector y.\n- `y`: Vector representing the output vector y. It is also the initial value of y that incorporates the existing values.\n- `M`: Number of rows in the matrix A.\n- `N`: Number of columns in the matrix A.\n\nThe function implementation would involve iterating over the COO format sparse matrix elements, computing the matrix-vector product, and applying alpha and beta as specified. The result will be stored in the output vector y.\n\nHere's a basic outline of the implementation:\n1. Initialize all elements in the output vector y with beta*y.\n2. Iterate over the sparse matrix elements in COO format.\n3. For each element in A, calculate the corresponding product and add it to the respective element in y.\n4. Modify the elements in y with the appropriate scalar multipliers alpha and beta.\n\nIf you have any specific questions or need further clarification on any part of the implementation, feel free to ask!"}
{"algo": "sparse_la", "spec": "48_sparse_la_sparse_axpy", "prompt": "struct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {", "completion": "To implement the `sparseAxpy` function in C++, you can follow the provided example and create the function as shown below. It takes in three parameters: `alpha` as a double representing the scalar multiplier, `x` as a vector of sparse elements representing the first sparse vector, `y` as a vector of sparse elements representing the second sparse vector, and modifies the `z` vector to store the result of the operation `z = alpha*x + y`.\n\nHere's the implementation:\n\n```cpp\n#include <vector>\n#include <cmath>\n\nstruct Element {\n    size_t index;\n    double value;\n};\n\nvoid sparseAxpy(double alpha, const std::vector<Element>& x, const std::vector<Element>& y, std::vector<double>& z) {\n    // Initialize the result vector z with the same size as the longer of x and y\n    size_t zSize = std::max(x.size(), y.size());\n    z.resize(zSize);\n\n    // Perform the operation z = alpha*x + y\n    for (const Element& elem : x) {\n        z[elem.index] += alpha * elem.value;\n    }\n\n    for (const Element& elem : y) {\n        z[elem.index] += elem.value;\n    }\n}\n```\n\nThis function iterates over the elements of the input vectors `x` and `y`, computes the result `z = alpha*x + y`, and stores the result in the output vector `z`. It uses the index of each element as the index in the result vector `z` and applies the appropriate scaling as per the operation.\n\nYou can call this function with your sample input vectors `x`, `y`, and `alpha` to perform the specified operation and store the result in `z`."}
{"algo": "sparse_la", "spec": "49_sparse_la_sparse_lu_decomp", "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {", "completion": "To factorize the sparse matrix A into LU where L is lower triangular and U is upper triangular, we need to implement the LU factorization algorithm. Here's a rough outline of how you can do this using the COO format for the input matrix A:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid assembleLU(const std::vector<COOElement> &A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n    L.resize(A.size());\n    U.resize(A.size());\n\n    // Initialize L to identity matrix and U to zeros\n    for (size_t i = 0; i < A.size(); ++i) {\n        if (A[i].row == A[i].column) {\n            L[i] = 1.0;\n            U[i] = A[i].value;\n        } else {\n            L[i] = 0.0;\n            U[i] = 0.0;\n        }\n    }\n\n    // Apply LU decomposition algorithm\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t i = 0; i < A.size(); ++i) {\n            if (A[i].row > k) {\n                continue; // Skip entries above the diagonal\n            }\n\n            if (A[i].column == k) {\n                L[i] = A[i].value / U[k * N + k];\n            } else if (A[i].row == k) {\n                U[i] = A[i].value;\n            } else if (A[i].row < k && A[i].column > k) {\n                U[i] -= L[A[i].row * N + k] * U[k * N + A[i].column];\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<COOElement> A = {{0, 0, 4}, {0, 1, 3}, {1, 0, 6}, {1, 1, 3}};\n    size_t N = 2; // Assuming N = 2 for the given example\n\n    std::vector<double> L, U;\n    assembleLU(A, L, U, N);\n\n    // Output the factorized matrices L and U\n    std::cout << \"L:\\n\";\n    for (const auto &elem : L) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"U:\\n\";\n    for (const auto &elem : U) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n\nIn this code:\n- The `assembleLU` function constructs the L and U matrices based on the input sparse matrix A using the LU factorization algorithm.\n- The main function sets up the input matrix A, calls the `assembleLU` function, and then outputs the resulting L and U matrices.\n\nYou can further optimize and refine the algorithm based on your requirements and the characteristics of the input sparse matrix."}
{"algo": "stencil", "spec": "50_stencil_xor_kernel", "prompt": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {", "completion": "To implement the logic you described for the `cellsXOR` function, you can iterate over each cell in the grid and count the number of neighboring cells that have a value of 1. If the count is exactly 1, then the current cell in the output grid should be set to 1; otherwise, it should be set to 0.\n\nHere is a possible implementation for the `cellsXOR` function in C++:\n\n```cpp\n#include <vector>\n\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n\n            if (i > 0 && input[(i - 1) * N + j] == 1) count++; // Check top neighbor\n            if (i < N - 1 && input[(i + 1) * N + j] == 1) count++; // Check bottom neighbor\n            if (j > 0 && input[i * N + (j - 1)] == 1) count++; // Check left neighbor\n            if (j < N - 1 && input[i * N + (j + 1)] == 1) count++; // Check right neighbor\n\n            output[i * N + j] = (count == 1) ? 1 : 0;\n        }\n    }\n}\n```\n\nIn this implementation:\n- We iterate over each cell `(i, j)` in the grid and count the number of neighboring cells that have a value of 1.\n- Based on the count, we set the value of the current cell in the output grid (`output`) accordingly.\n\nYou can call this `cellsXOR` function with your input and output grids to update the output grid as per your requirements."}
{"algo": "stencil", "spec": "51_stencil_edge_kernel", "prompt": "const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {", "completion": "To implement the `convolveKernel` function to apply the edge kernel convolution on a grayscale image, you can follow these steps:\n\n1. Define the function signature and parameters.\n2. Implement the convolution logic considering the edge cases.\n3. Clip the output values to the range of 0 to 255.\n\nHere's the complete implementation:\n\n```cpp\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    // Helper function to get pixel value at row x, column y in the 1D image vector\n    auto getPixel = [&](int x, int y) -> int {\n        if (x >= 0 && x < N && y >= 0 && y < N) {\n            return imageIn[x * N + y];\n        }\n        return 0;  // Return 0 for pixels outside boundary\n    };\n\n    // Apply edge kernel convolution\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int pixel = getPixel(i + k, j + l);\n                    sum += pixel * edgeKernel[k + 1][l + 1];\n                }\n            }\n            imageOut[i * N + j] = std::max(0, std::min(255, sum)); // Clip the output\n        }\n    }\n}\n```\n\nYou can now call this `convolveKernel` function with the input and output images to apply the edge kernel convolution as described in the example you provided."}
{"algo": "stencil", "spec": "52_stencil_1d_jacobi_3-point_stencil", "prompt": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {", "completion": "Here is an implementation of the jacobi1D function according to the provided description:\n\n```cpp\n#include <vector>\n\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    int n = input.size();\n\n    // Compute first element\n    output[0] = (n > 1) ? (input[0] + input[1]) / 3.0 : 0.0;\n\n    // Compute middle elements\n    for (int i = 1; i < n - 1; ++i) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3.0;\n    }\n\n    // Compute last element\n    output[n - 1] = (n > 1) ? (input[n - 2] + input[n - 1]) / 3.0 : 0.0;\n}\n```\n\nThis function takes a constant reference to the input vector and a reference to the output vector and computes one iteration of a 3-point 1D Jacobi stencil on the input, storing the results in the output vector. The function computes the average of each element with its two neighbors according to the provided formula. It handles the boundary cases by replacing elements beyond the boundary with 0."}
{"algo": "stencil", "spec": "53_stencil_2d_jacobi_5-point_stencil", "prompt": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {", "completion": "Here is the code to compute one iteration of a 5-point 2D Jacobi stencil on the `input` and store the results in `output`:\n\n```cpp\n#include <vector>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    // Loop over the 2D grid\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            // Calculate the indices for neighbor elements\n            size_t left = (j == 0) ? 0 : i*N + (j-1);\n            size_t right = (j == N-1) ? 0 : i*N + (j+1);\n            size_t up = (i == 0) ? 0 : (i-1)*N + j;\n            size_t down = (i == N-1) ? 0 : (i+1)*N + j;\n\n            // Compute the Jacobi value of the current element\n            output[i*N + j] = (input[left] + input[right] + input[up] + input[down] + input[i*N + j]) / 5.0;\n        }\n    }\n}\n```\n\nThis function performs the Jacobi stencil computation on the input grid, taking into account the boundary conditions by replacing out-of-bounds accesses with 0. The results are stored in the `output` grid."}
{"algo": "stencil", "spec": "54_stencil_game_of_life", "prompt": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {", "completion": "To simulate one generation of Game of Life based on the provided rules, we can iterate over each cell in the input grid, count the number of live neighbors for each cell, and update the cells in the output grid accordingly.\n\nHere is the complete C++ function definition to achieve this:\n\n```cpp\n#include <vector>\n\nvoid gameOfLife(std::vector<int> const& input, std::vector<int>& output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int liveNeighbors = 0;\n            // Check all 8 neighbors around the current cell\n            for (int di = -1; di <= 1; ++di) {\n                for (int dj = -1; dj <= 1; ++dj) {\n                    if (di == 0 && dj == 0) continue; // Skip the current cell\n                    int ni = i + di;\n                    int nj = j + dj;\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        liveNeighbors += input[ni * N + nj];\n                    }\n                }\n            }\n\n            // Apply the rules of the Game of Life\n            if (input[i * N + j] == 1) {\n                if (liveNeighbors < 2 || liveNeighbors > 3) {\n                    output[i * N + j] = 0; // Cell dies\n                } else {\n                    output[i * N + j] = 1; // Cell lives on\n                }\n            } else {\n                if (liveNeighbors == 3) {\n                    output[i * N + j] = 1; // Cell becomes alive\n                } else {\n                    output[i * N + j] = 0; // Cell remains dead\n                }\n            }\n        }\n    }\n}\n```\n\nYou can call this function with the input grid, the output grid where the new generation will be stored, and the size of the grid (N). After the function call, the `output` grid will contain the results of simulating one generation of the Game of Life based on the input grid."}
{"algo": "transform", "spec": "55_transform_relu", "prompt": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {", "completion": "To implement the ReLU (Rectified Linear Unit) function on each element of the input vector `x`, you can iterate over each element and apply the ReLU transformation, which sets negative values to zero and keeps non-negative values unchanged. Here is how you can complete the `relu` function:\n\n```cpp\n#include <vector>\n\nvoid relu(std::vector<double> &x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] < 0) {\n            x[i] = 0;  // Setting negative values to zero\n        }\n        // Non-negative values stay the same\n    }\n}\n```\n\nYou can call this function with the input vector provided in your example to compute the ReLU function on it. Let me know if you need further assistance or have any more questions!"}
{"algo": "transform", "spec": "56_transform_negate_odds", "prompt": "/* In the vector x negate the odd values and divide the even values by 2.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {", "completion": "Here's the code snippet that accomplishes the task:\n\n```cpp\n#include <vector>\n\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    for (int &num : x) {\n        if (num % 2 == 0) {\n            num /= 2;  // divide even numbers by 2\n        } else {\n            num = -num;  // negate odd numbers\n        }\n    }\n}\n```\n\nYou can call this function with a vector of integers as an argument to achieve the desired outcome."}
{"algo": "transform", "spec": "57_transform_inverse_offset", "prompt": "/* Replace every element of the vector x with 1-1/x.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {", "completion": "To implement the function `oneMinusInverse`, you can iterate over the elements of the vector `x` and apply the transformation `1 - 1/x[i]` to each element. Here is the implementation of the function:\n\n```cpp\n#include <vector>\n\nvoid oneMinusInverse(std::vector<double> &x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            x[i] = 1.0 - 1.0 / x[i];\n        }\n    }\n}\n```\n\nYou can call this function passing your input vector to update its elements according to the transformation specified."}
{"algo": "transform", "spec": "58_transform_squaring", "prompt": "/* Replace every element of x with the square of its value.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {", "completion": "To implement the `squareEach` function, you can iterate over the elements of the input vector `x` and square each element in place using the reference passed to the vector. Here is how you can write the implementation:\n\n```cpp\n#include <vector>\n\nvoid squareEach(std::vector<int> &x) {\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i]; // Square each element\n    }\n}\n```\n\nThis function iterates over each element of the vector `x` and replaces each element with its square."}
{"algo": "transform", "spec": "59_transform_map_function", "prompt": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {", "completion": "Here is the completed implementation of the `mapPowersOfTwo` function using the provided `isPowerOfTwo` function to determine whether each element in the input vector `x` is a power of two or not. The results are stored in the `mask` vector:\n\n```cpp\n#include <vector>\n\nbool isPowerOfTwo(int x) {\n    return (x > 0) && !(x & (x - 1));\n}\n\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    mask.clear();  // Clear the mask vector before populating it\n    mask.reserve(x.size());  // Reserve space for the elements\n\n    for (int num : x) {\n        mask.push_back(isPowerOfTwo(num));\n    }\n}\n\nint main() {\n    std::vector<int> input = {8, 0, 9, 7, 15, 64, 3};\n    std::vector<bool> output;\n\n    mapPowersOfTwo(input, output);\n\n    // Output the results\n    for (size_t i = 0; i < input.size(); ++i) {\n        std::cout << \"Input: \" << input[i] << \", Output: \" << (output[i] ? \"true\" : \"false\") << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis code snippet defines the `mapPowersOfTwo` function that takes the input vector `x` and the output vector `mask` and populates the `mask` vector based on whether each element in `x` is a power of two. You can use this code in your project to achieve the desired functionality."}
