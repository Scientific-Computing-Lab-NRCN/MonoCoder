[
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "00_dense_la_lu_decomp",
        "parallelism_model": "serial",
        "prompt": "/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <iostream>\n\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t i = k + 1; i < N; ++i) {\n            A[i * N + k] /= A[k * N + k];\n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= A[i * N + k] * A[k * N + j];\n            }\n        }\n    }\n\n    std::cout << \"Matrix L + U: \\n\";\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            if (j < i) {\n                // Below diagonal (L)\n                std::cout << A[i * N + j] << \"\\t\";\n            } else {\n                // Above or on diagonal (U)\n                std::cout << A[i * N + j] << \"\\t\";\n            }\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nint main() {\n    std::vector<double> A = {4, 3, 6, 3}; // NxN matrix data in row-major order\n    size_t N = 2; // Size of the matrix\n\n    luFactorize(A, N);\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "00_dense_la_lu_decomp",
        "parallelism_model": "omp",
        "prompt": "/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <omp.h>\n\n// Function to perform LU factorization in parallel\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    #pragma omp parallel for\n    for (size_t k = 0; k < N - 1; ++k) {\n        for (size_t i = k + 1; i < N; ++i) {\n            A[i * N + k] /= A[k * N + k];\n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= A[i * N + k] * A[k * N + j];\n            }\n        }\n    }\n}\n\nint main() {\n    // Define the input matrix\n    std::vector<double> A = {4, 3, 6, 3};\n    size_t N = 2;\n\n    // Perform LU factorization and store the results in A\n    luFactorize(A, N);\n\n    // Print the result (LU factorization stored in place)\n    std::cout << \"LU Factorization result:\" << std::endl;\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            std::cout << A[i * N + j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "01_dense_la_solve",
        "parallelism_model": "serial",
        "prompt": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    // Convert the row-major vector A to a 2D matrix A_matrix\n    std::vector<std::vector<double>> A_matrix(N, std::vector<double>(N));\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            A_matrix[i][j] = A[i * N + j];\n        }\n    }\n\n    // Gaussian elimination\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = i + 1; j < N; j++) {\n            double ratio = A_matrix[j][i] / A_matrix[i][i];\n            for (size_t k = 0; k < N; k++) {\n                A_matrix[j][k] -= ratio * A_matrix[i][k];\n            }\n            b[j] -= ratio * b[i];\n        }\n    }\n\n    // Back-substitution to get x\n    x.resize(N);\n    for (int i = N - 1; i >= 0; i--) {\n        x[i] = b[i];\n        for (size_t j = i + 1; j < N; j++) {\n            x[i] -= A_matrix[i][j] * x[j];\n        }\n        x[i] /= A_matrix[i][i];\n    }\n}\n\nint main() {\n    std::vector<double> A = {1, 4, 2, 1, 2, 3, 2, 1, 3};\n    std::vector<double> b = {11, 11, 13};\n    std::vector<double> x;\n\n    size_t N = 3;\n    solveLinearSystem(A, b, x, N);\n\n    for (size_t i = 0; i < N; i++) {\n        std::cout << \"x[\" << i << \"] = \" << x[i] << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "01_dense_la_solve",
        "parallelism_model": "omp",
        "prompt": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <omp.h>\n\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    // Convert the row-major vector A to a 2D matrix A_matrix\n    std::vector<std::vector<double>> A_matrix(N, std::vector<double>(N));\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            A_matrix[i][j] = A[i * N + j];\n        }\n    }\n\n    // Gaussian elimination\n    for (size_t i = 0; i < N; i++) {\n        #pragma omp parallel for\n        for (size_t j = i + 1; j < N; j++) {\n            double ratio = A_matrix[j][i] / A_matrix[i][i];\n            for (size_t k = 0; k < N; k++) {\n                A_matrix[j][k] -= ratio * A_matrix[i][k];\n            }\n            b[j] -= ratio * b[i];\n        }\n    }\n\n    // Back-substitution to get x\n    x.resize(N);\n    #pragma omp parallel for\n    for (int i = N - 1; i >= 0; i--) {\n        x[i] = b[i];\n        for (size_t j = i + 1; j < N; j++) {\n            x[i] -= A_matrix[i][j] * x[j];\n        }\n        x[i] /= A_matrix[i][i];\n    }\n}\n\nint main() {\n    std::vector<double> A = {1, 4, 2, 1, 2, 3, 2, 1, 3};\n    std::vector<double> b = {11, 11, 13};\n    std::vector<double> x;\n\n    size_t N = 3;\n    solveLinearSystem(A, b, x, N);\n\n    for (size_t i = 0; i < N; i++) {\n        std::cout << \"x[\" << i << \"] = \" << x[i] << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "02_dense_la_gemm",
        "parallelism_model": "serial",
        "prompt": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {",
        "outputs": [
            "\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            C[i * N + j] = 0;\n            for (size_t k = 0; k < K; ++k) {\n                C[i * N + j] += A[i * K + k] * B[k * N + j];\n            }\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "02_dense_la_gemm",
        "parallelism_model": "omp",
        "prompt": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid gemm(std::vector<double>& A, std::vector<double>& B, std::vector<double>& C, size_t M, size_t K, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "03_dense_la_axpy",
        "parallelism_model": "serial",
        "prompt": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {",
        "outputs": [
            "\n#include <vector>\n\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    // Check if the sizes of x and y are compatible\n    if (x.size() != y.size()) {\n        // Handle the error (e.g., throw an exception or return an error code)\n        return;\n    }\n\n    // Resize z to match the size of x and y\n    z.resize(x.size());\n\n    // Compute z = alpha*x + y\n    for (size_t i = 0; i < x.size(); ++i) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n\nint main() {\n    // Example usage\n    std::vector<double> x = {1, -5, 2, 9};\n    std::vector<double> y = {0, 4, 1, -1};\n    std::vector<double> z;\n\n    double alpha = 2;\n    axpy(alpha, x, y, z);\n\n    // Print the result\n    for (double result : z) {\n        std::cout << result << \" \";\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "03_dense_la_axpy",
        "parallelism_model": "omp",
        "prompt": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {",
        "outputs": [
            "\n#include <omp.h>\n#include <vector>\n\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    int size = x.size();\n\n    #pragma omp parallel for\n    for (int i = 0; i < size; i++) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "04_dense_la_gemv",
        "parallelism_model": "serial",
        "prompt": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n\nvoid gemv(const std::vector<double>& A, const std::vector<double>& x, std::vector<double>& y, size_t M, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        y[i] = 0;\n        for (size_t j = 0; j < N; ++j) {\n            y[i] += A[i * N + j] * x[j];\n        }\n    }\n}\n\nint main() {\n    // Example input\n    std::vector<double> A = {1, -1, 2, 0, -3, 1};\n    std::vector<double> x = {2, 1, 0};\n    std::vector<double> y(2); // Size M = 2\n\n    // Perform the matrix-vector multiplication\n    gemv(A, x, y, 2, 3);\n\n    // Display the result\n    std::cout << \"Result y = [\";\n    for (size_t i = 0; i < y.size(); ++i) {\n        std::cout << y[i] << (i < y.size() - 1 ? \", \" : \"\");\n    }\n    std::cout << \"]\" << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "04_dense_la_gemv",
        "parallelism_model": "omp",
        "prompt": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        y[i] = 0.0;\n        for (size_t j = 0; j < N; ++j) {\n            y[i] += A[i * N + j] * x[j];\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "05_fft_inverse_fft",
        "parallelism_model": "serial",
        "prompt": "/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {",
        "outputs": [
            "\n   #include <complex>\n   "
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "05_fft_inverse_fft",
        "parallelism_model": "omp",
        "prompt": "/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <complex>\n#include <omp.h>\n\n/* forward declare fft. computes Fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse Fourier transform of x in-place using OpenMP for parallelization */\nvoid ifft(std::vector<std::complex<double>> &x) {\n    // Calculate the size of the input vector\n    int N = x.size();\n\n    // Compute inverse Fourier transform in parallel\n    #pragma omp parallel for\n    for (int k = 0; k < N; ++k) {\n        x[k] = std::conj(x[k]);\n    }\n    \n    // Forward FFT\n    fft(x);\n    \n    // Compute final result and normalize\n    #pragma omp parallel for\n    for (int k = 0; k < N; ++k) {\n        x[k] = std::conj(x[k]) / static_cast<double>(N);\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "06_fft_dft",
        "parallelism_model": "serial",
        "prompt": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {",
        "outputs": [
            "\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <vector>\n\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n    size_t N = x.size();\n    for (size_t k = 0; k < N; ++k) {\n        output[k] = {0.0, 0.0};\n        for (size_t n = 0; n < N; ++n) {\n            double angle = 2.0 * M_PI * k * n / N;\n            output[k] += std::polar(x[n], -angle);\n        }\n    }\n}\n\nint main() {\n    std::vector<double> input = {1, 4, 9, 16};\n    std::vector<std::complex<double>> output(input.size());\n\n    dft(input, output);\n\n    // Output the result\n    for (size_t i = 0; i < output.size(); ++i) {\n        std::cout << output[i] << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "06_fft_dft",
        "parallelism_model": "omp",
        "prompt": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {",
        "outputs": [
            "\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <omp.h>\n\nvoid dft(const std::vector<double> &x, std::vector<std::complex<double>> &output) {\n    size_t N = x.size();\n    output.resize(N, std::complex<double>(0, 0));\n\n    #pragma omp parallel for\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t n = 0; n < N; ++n) {\n            output[k] += x[n] * std::polar(1.0, -2 * M_PI * k * n / N);\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "07_fft_fft_conjugate",
        "parallelism_model": "serial",
        "prompt": "/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <complex>\n#include <cmath>\n\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\n    int n = x.size();\n    \n    if (n <= 1) {\n        return;\n    }\n    \n    std::vector<std::complex<double>> even(n/2), odd(n/2);\n    \n    for (int i = 0; i < n / 2; ++i) {\n        even[i] = x[i * 2];\n        odd[i] = x[i * 2 + 1];\n    }\n    \n    fftConjugate(even);\n    fftConjugate(odd);\n    \n    for (int k = 0; k < n / 2; ++k) {\n        std::complex<double> t = std::polar(1.0, -2 * M_PI * k / n) * odd[k];\n        x[k] = even[k] + t;\n        x[k + n / 2] = even[k] - t;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "07_fft_fft_conjugate",
        "parallelism_model": "omp",
        "prompt": "/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <omp.h>\n\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\n    int n = x.size();\n    \n    #pragma omp parallel for\n    for (int k = 0; k < n; k++) {\n        for (int j = 0; j < n; j++) {\n            double theta = -2.0 * M_PI * j * k / n;\n            std::complex<double> factor(std::cos(theta), std::sin(theta));\n\n            if (j < k) {\n                std::swap(x[j], x[k]);\n            }\n            x[k] += x[j] * factor;\n        }\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        x[i] = std::conj(x[i]); // Conjugate the imaginary part\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "08_fft_split_fft",
        "parallelism_model": "serial",
        "prompt": "/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {",
        "outputs": [
            "\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    int N = x.size();\n    std::vector<std::complex<double>> X(N);\n    \n    std::copy(x.begin(), x.end(), X.begin());\n    std::fft(X.data(), N);\n    \n    r.resize(N);\n    i.resize(N);\n    \n    for (int k = 0; k < N; ++k) {\n        r[k] = X[k].real();\n        i[k] = X[k].imag();\n    }\n}\n\nint main() {\n    std::vector<std::complex<double>> x = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n    std::vector<double> r, i;\n    \n    fft(x, r, i);\n    \n    std::cout << \"Real part: \";\n    for (auto val : r) {\n        std::cout << val << \" \";\n    }\n    \n    std::cout << \"\\nImaginary part: \";\n    for (auto val : i) {\n        std::cout << val << \" \";\n    }\n    \n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "08_fft_split_fft",
        "parallelism_model": "omp",
        "prompt": "/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <fftw3.h>\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    int N = x.size();\n    r.resize(N);\n    i.resize(N);\n\n    fftw_complex *in, *out;\n    fftw_plan plan;\n\n    in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * N);\n    out = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * N);\n\n    // Create FFTW plan\n    plan = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    // Fill input array\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        in[i][0] = x[i].real();\n        in[i][1] = x[i].imag();\n    }\n\n    // Execute FFT\n    fftw_execute(plan);\n\n    // Retrieve results\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        r[i] = out[i][0];\n        i[i] = out[i][1];\n    }\n\n    fftw_destroy_plan(plan);\n    fftw_free(in);\n    fftw_free(out);\n}\n\nint main() {\n    // Example input signal\n    std::vector<std::complex<double>> signal = {{1.0, 0.0}, {1.0, 0.0}, {1.0, 0.0}, {1.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}};\n    std::vector<double> real_part, imag_part;\n\n    // Call FFT function\n    fft(signal, real_part, imag_part);\n\n    // Output the results\n    std::cout << \"Real part: \";\n    for (const auto& val : real_part) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::cout << \"Imaginary part: \";\n    for (const auto& val : imag_part) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "09_fft_fft_out_of_place",
        "parallelism_model": "serial",
        "prompt": "/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {",
        "outputs": [
            "\n#include <vector>\n#include <complex>\n#include <fftw3.h>\n\nvoid fft(const std::vector<std::complex<double>>& x, std::vector<std::complex<double>>& output) {\n    int N = x.size();\n    output.resize(N);\n\n    fftw_complex* in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n    fftw_complex* out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n\n    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    // Copy input data to fftw_complex array\n    for (int i = 0; i < N; ++i) {\n        in[i][0] = x[i].real();\n        in[i][1] = x[i].imag();\n    }\n\n    fftw_execute(p);\n\n    // Copy FFT result to output\n    for (int i = 0; i < N; ++i) {\n        output[i] = std::complex<double>(out[i][0], out[i][1]);\n    }\n\n    fftw_destroy_plan(p);\n    fftw_free(in);\n    fftw_free(out);\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "09_fft_fft_out_of_place",
        "parallelism_model": "omp",
        "prompt": "/* Compute the fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {",
        "outputs": [
            "\n#include <vector>\n#include <complex>\n#include <omp.h>\n\nvoid fft(const std::vector<std::complex<double>>& x, std::vector<std::complex<double>>& output) {\n    // Ensure output size matches input size\n    if (x.size() != output.size()) {\n        output.resize(x.size());\n    }\n\n    #pragma omp parallel for\n    for (int k = 0; k < x.size(); ++k) {\n        std::complex<double> sum = 0.0;\n        for (int n = 0; n < x.size(); ++n) {\n            double angle = -2 * M_PI * k * n / x.size();\n            sum += x[n] * std::polar(1.0, angle);\n        }\n        output[k] = sum;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "10_geometry_convex_hull",
        "parallelism_model": "serial",
        "prompt": "struct Point {\n   double x, y;\n};\n\n/* Find the set of points that defined the smallest convex polygon that contains all the points in the vector points. Store the result in `hull`.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: [{0, 3}, {4, 4}, {3, 1}, {0, 0}]\n*/\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {",
        "outputs": [
            "\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0; // Collinear\n    return (val > 0) ? 1 : 2; // Clockwise or counterclockwise\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "10_geometry_convex_hull",
        "parallelism_model": "omp",
        "prompt": "struct Point {\n   double x, y;\n};\n\n/* Find the set of points that defined the smallest convex polygon that contains all the points in the vector points. Store the result in `hull`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: [{0, 3}, {4, 4}, {3, 1}, {0, 0}]\n*/\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <omp.h>\n\nstruct Point {\n    double x, y;\n};\n\n// Calculate the cross product of vectors (p1, p2) and (p2, p3)\ndouble crossProduct(const Point& p1, const Point& p2, const Point& p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\n// Sort points based on polar angle from the anchor point\nbool polarSortComparator(const Point& a, const Point& b, const Point& anchor) {\n    double cross = crossProduct(anchor, a, b);\n    if (cross != 0) return cross > 0;\n    // If collinear, put the closest point first\n    return std::hypot(a.x - anchor.x, a.y - anchor.y) < std::hypot(b.x - anchor.x, b.y - anchor.y);\n}\n\n// Construct the convex hull of a set of points using Graham's Scan with parallelization\nvoid convexHull(std::vector<Point> const& points, std::vector<Point>& hull) {\n    hull.clear();\n\n    if (points.size() < 3) { // In case of less than 3 points, convex hull is the input points\n        hull = points;\n        return;\n    }\n\n    // Find the point with the lowest y-coordinate (and leftmost if ties)\n    Point anchor = *std::min_element(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.y < b.y || (a.y == b.y && a.x < b.x);\n    });\n\n    std::vector<Point> sortedPoints = points;\n    \n    // Sort the rest of the points based on polar angle from the anchor point\n    std::sort(sortedPoints.begin(), sortedPoints.end(),\n              [&](const Point& a, const Point& b) {\n                  return polarSortComparator(a, b, anchor);\n              });\n\n    hull.push_back(sortedPoints[0]);\n    hull.push_back(sortedPoints[1]);\n\n    #pragma omp parallel for default(none) shared(hull) shared(sortedPoints) firstprivate(anchor)\n    for (size_t i = 2; i < sortedPoints.size(); ++i) {\n        while (hull.size() >= 2 && crossProduct(*(hull.end() - 2), hull.back(), sortedPoints[i]) <= 0) {\n            #pragma omp critical\n            hull.pop_back();\n        }\n        #pragma omp critical\n        hull.push_back(sortedPoints[i]);\n    }\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "11_geometry_convex_hull_perimeter",
        "parallelism_model": "serial",
        "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the perimeter of the smallest convex polygon that contains all the points in the vector points.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: 13.4477\n*/\ndouble convexHullPerimeter(std::vector<Point> const& points) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\n// Helper function to calculate cross product\ndouble crossProduct(Point const& o, Point const& a, Point const& b) {\n    return (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);\n}\n\n// Function to compute convex hull\nstd::vector<Point> convexHull(std::vector<Point> points) {\n    int n = points.size();\n    if (n <= 3) {\n        return points;\n    }\n\n    std::sort(points.begin(), points.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    std::vector<Point> hull;\n    int k = 0;\n\n    // Lower Hull\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && crossProduct(hull[k - 2], hull[k - 1], points[i]) <= 0) {\n            hull.pop_back();\n            k--;\n        }\n        hull.push_back(points[i]);\n        k++;\n    }\n\n    // Upper Hull\n    for (int i = n - 2, t = k + 1; i >= 0; --i) {\n        while (k >= t && crossProduct(hull[k - 2], hull[k - 1], points[i]) <= 0) {\n            hull.pop_back();\n            k--;\n        }\n        hull.push_back(points[i]);\n        k++;\n    }\n\n    hull.pop_back(); // Last point is duplicated\n\n    return hull;\n}\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    std::vector<Point> convexHullPoints = convexHull(points);\n\n    double perimeter = 0;\n    for (size_t i = 0; i < convexHullPoints.size(); ++i) {\n        perimeter += distance(convexHullPoints[i], convexHullPoints[(i + 1) % convexHullPoints.size()]);\n    }\n\n    return perimeter;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "11_geometry_convex_hull_perimeter",
        "parallelism_model": "omp",
        "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the perimeter of the smallest convex polygon that contains all the points in the vector points.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: 13.4477\n*/\ndouble convexHullPerimeter(std::vector<Point> const& points) {",
        "outputs": [
            "\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <omp.h>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    double totalPerimeter = 0.0;\n    int n = points.size();\n\n    // Calculate distances between all pairs of points\n    std::vector<std::vector<double>> distances(n, std::vector<double>(n, 0.0));\n    #pragma omp parallel for collapse(2) shared(distances)\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            distances[i][j] = distances[j][i] = distance(points[i], points[j]);\n        }\n    }\n\n    // Find the convex hull perimeter\n    #pragma omp parallel for reduction(+:totalPerimeter)\n    for (int i = 0; i < n; i++) {\n        double minDist = std::numeric_limits<double>::max();\n        for (int j = 0; j < n; j++) {\n            if (i != j) {\n                minDist = std::min(minDist, distances[i][j]);\n            }\n        }\n        totalPerimeter += minDist;\n    }\n\n    return totalPerimeter;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "12_geometry_smallest_triangle",
        "parallelism_model": "serial",
        "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm> // for std::min_element\n#include <cmath>     // for std::abs\n#include <limits>    // for std::numeric_limits\n\nstruct Point {\n    double x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n    return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points */\ndouble smallestArea(std::vector<Point> const& points) {\n    double minArea = std::numeric_limits<double>::max();\n\n    // Generate all combinations of 3 points\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            for (size_t k = j + 1; k < points.size(); ++k) {\n                double area = triangleArea(points[i], points[j], points[k]);\n                minArea = std::min(area, minArea);\n            }\n        }\n    }\n\n    return minArea;\n}\n\nint main() {\n    // Example usage\n    std::vector<Point> points = {{0, 10}, {5, 5}, {1, 0}, {-1, 1}, {-10, 0}};\n    double result = smallestArea(points);\n    return result;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "12_geometry_smallest_triangle",
        "parallelism_model": "omp",
        "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <omp.h>\n#include \"Point.h\"  // assuming Point struct is defined in Point.h\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs(A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));\n}\n\ndouble smallestArea(std::vector<Point> const& points) {\n  double minArea = std::numeric_limits<double>::max();\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < points.size(); ++i) {\n    for (size_t j = i + 1; j < points.size(); ++j) {\n      for (size_t k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n\n  return minArea;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "13_geometry_closest_pair_2d",
        "parallelism_model": "serial",
        "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {",
        "outputs": [
            "\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\ndouble closestPair(std::vector<Point> const& points) {\n    double minDistance = std::numeric_limits<double>::max();\n\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            minDistance = std::min(minDistance, distance(points[i], points[j]));\n        }\n    }\n\n    return minDistance;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "13_geometry_closest_pair_2d",
        "parallelism_model": "omp",
        "prompt": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {",
        "outputs": [
            "\ndouble closestPair(std::vector<Point> const& points) {\n    double minDistance = std::numeric_limits<double>::max();\n    \n    // Use OpenMP for parallel execution\n    #pragma omp parallel for\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            double d = distance(points[i], points[j]); // Calculate the distance between points[i] and points[j]\n            \n            // Update minDistance if a closer pair of points is found\n            #pragma omp critical\n            {\n                minDistance = std::min(minDistance, d);\n            }\n        }\n    }\n\n    return minDistance;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "14_geometry_closest_pair_1d",
        "parallelism_model": "serial",
        "prompt": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\ndouble distance(double x1, double x2) {\n    return std::abs(x1 - x2);\n}\n\ndouble closestPair(std::vector<double> const& x) {\n    std::vector<double> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n\n    double min_distance = std::numeric_limits<double>::max();\n\n    for (size_t i = 0; i < sorted_x.size() - 1; ++i) {\n        double curr_distance = distance(sorted_x[i], sorted_x[i + 1]);\n        min_distance = std::min(min_distance, curr_distance);\n    }\n\n    return min_distance;\n}\n\nint main() {\n    std::vector<double> x = {7, 3, 9, 12, 31, 1};\n    double result = closestPair(x);\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "14_geometry_closest_pair_1d",
        "parallelism_model": "omp",
        "prompt": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {",
        "outputs": [
            "\n\tdouble minDistance = std::numeric_limits<double>::max();\n\n\t#pragma omp parallel for\n\tfor (int i = 0; i < x.size(); ++i) {\n\t\tfor (int j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < minDistance) {\n\t\t\t\t\tminDistance = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minDistance;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "15_graph_edge_count",
        "parallelism_model": "serial",
        "prompt": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n\nint edgeCount(std::vector<int> const& A, size_t N) {\n    int count = 0;\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (A[i * N + j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<std::vector<int>> input = {{0, 0, 0, 1}, {0, 0, 0, 1}, {0, 0, 0, 1}, {1, 1, 1, 0}};\n    size_t N = input.size();\n\n    std::vector<int> flattened_input;\n     for (const auto& row : input) {\n        flattened_input.insert(flattened_input.end(), row.begin(), row.end());\n    }\n\n    int result = edgeCount(flattened_input, N);\n    std::cout << \"Number of edges: \" << result << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "15_graph_edge_count",
        "parallelism_model": "omp",
        "prompt": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <omp.h>\n#include <vector>\n\nint edgeCount(std::vector<int> const& A, size_t N) {\n    int count = 0;\n    \n    #pragma omp parallel for reduction(+:count)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            if (A[i * N + j] == 1) {\n                #pragma omp critical\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "16_graph_largest_component",
        "parallelism_model": "serial",
        "prompt": "/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <stack>\n#include <unordered_set>\n\nint DFS(std::vector<int> const& A, size_t N, int start, std::unordered_set<int>& visited) {\n    int count = 0;\n    \n    std::stack<int> stack;\n    stack.push(start);\n    \n    while (!stack.empty()) {\n        int current = stack.top();\n        stack.pop();\n        \n        if (visited.count(current) == 0) {\n            visited.insert(current);\n            count++;\n            \n            for (int i = 0; i < N; ++i) {\n                if (A[current * N + i] == 1 && visited.count(i) == 0) {\n                    stack.push(i);\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nint largestComponent(std::vector<int> const& A, size_t N) {\n    int maxComponentSize = 0;\n    std::unordered_set<int> visited;\n    \n    for (int i = 0; i < N; ++i) {\n        if (visited.count(i) == 0) {\n            int componentSize = DFS(A, N, i, visited);\n            if (componentSize > maxComponentSize) {\n                maxComponentSize = componentSize;\n            }\n        }\n    }\n    \n    return maxComponentSize;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "16_graph_largest_component",
        "parallelism_model": "omp",
        "prompt": "/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "17_graph_highest_degree",
        "parallelism_model": "serial",
        "prompt": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n\nint maxDegree(std::vector<int> const& A, size_t N) {\n    int maxDegree = 0;\n    \n    for (size_t i = 0; i < N; ++i) {\n        int degree = 0;\n        for (size_t j = 0; j < N; ++j) {\n            if (A[i * N + j] == 1) {\n                ++degree;\n            }\n        }\n        maxDegree = std::max(maxDegree, degree);\n    }\n    \n    return maxDegree;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "17_graph_highest_degree",
        "parallelism_model": "omp",
        "prompt": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nint maxDegree(std::vector<int> const& A, size_t N) {\n    int max_degree = 0;\n\n    #pragma omp parallel for reduction(max: max_degree)\n    for (size_t i = 0; i < N; ++i) {\n        int node_degree = 0;\n        for (size_t j = 0; j < N; ++j) {\n            if (A[i * N + j] != 0) {\n                // Assuming undirected graph, so each edge contributes 2 to the degree\n                node_degree += 2;\n            }\n        }\n        // Adjust for the loopback edge if any\n        if (A[i * N + i] != 0) {\n            node_degree--;\n        }\n        max_degree = std::max(max_degree, node_degree);\n    }\n\n    return max_degree;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "18_graph_count_components",
        "parallelism_model": "serial",
        "prompt": "/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <unordered_set>\n\nvoid dfs(const std::vector<int>& A, std::unordered_set<int>& visited, int current, int N) {\n    visited.insert(current);\n    for (int i = 0; i < N; ++i) {\n        if (A[current * N + i] == 1 && visited.find(i) == visited.end()) {\n            dfs(A, visited, i, N);\n        }\n    }\n}\n\nint componentCount(const std::vector<int>& A, size_t N) {\n    int count = 0;\n    std::unordered_set<int> visited;\n\n    for (int i = 0; i < N; ++i) {\n        if (visited.find(i) == visited.end()) {\n            dfs(A, visited, i, N);\n            ++count;\n        }\n    }\n\n    return count;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "18_graph_count_components",
        "parallelism_model": "omp",
        "prompt": "/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n\t Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid dfs(int node, std::vector<int> const& A, std::vector<bool>& visited, size_t N) {\n    visited[node] = true;\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        if (A[node * N + i] && !visited[i]) {\n            dfs(i, A, visited, N);\n        }\n    }\n}\n\nint componentCount(std::vector<int> const& A, size_t N) {\n    int components = 0;\n    std::vector<bool> visited(N, false);\n\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp parallel for\n            for (int j = 0; j < N; ++j) {\n                if (A[i * N + j] && !visited[j]) {\n                    dfs(j, A, visited, N);\n                }\n            }\n            components++;\n        }\n    }\n\n    return components;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "19_graph_shortest_path",
        "parallelism_model": "serial",
        "prompt": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {",
        "outputs": [
            "\n#include <vector>\n#include <queue>\n\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n    std::vector<bool> visited(N, false);\n    std::queue<std::pair<int, int>> q; // Pair of node and distance from source\n\n    q.push({source, 0});\n    visited[source] = true;\n\n    while (!q.empty()) {\n        int node = q.front().first;\n        int dist = q.front().second;\n        q.pop();\n\n        if (node == dest) {\n            return dist;\n        }\n\n        for (int i = 0; i < N; ++i) {\n            if (A[node * N + i] && !visited[i]) {\n                q.push({i, dist + 1});\n                visited[i] = true;\n            }\n        }\n    }\n\n    return -1; // If source and destination are not connected\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "19_graph_shortest_path",
        "parallelism_model": "omp",
        "prompt": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {",
        "outputs": [
            "\n#include <omp.h>\n#include <vector>\n#include <queue>\n\nint shortestPathLength(const std::vector<int>& A, size_t N, int source, int dest) {\n    std::vector<bool> visited(N, false);\n    std::vector<int> dist(N, -1);\n    \n    std::queue<int> q;\n    visited[source] = true;\n    dist[source] = 0;\n    q.push(source);\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        \n        #pragma omp parallel for\n        for (int i = 0; i < N; i++) {\n            if (A[curr * N + i] && !visited[i]) {\n                visited[i] = true;\n                dist[i] = dist[curr] + 1;\n                q.push(i);\n            }\n        }\n    }\n    \n    return dist[dest];\n}\n\nint main() {\n    // Example input\n    std::vector<int> A = {{0, 1, 1, 0}, {1, 0, 0, 1}, {1, 0, 0, 1}, {0, 1, 1, 0}};\n    size_t N = 4;\n    int source = 0, dest = 3;\n    \n    int shortestLength = shortestPathLength(A, N, source, dest);\n    std::cout << \"Shortest path length from source to dest: \" << shortestLength << std::endl;\n    \n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "20_histogram_pixel_histogram",
        "parallelism_model": "serial",
        "prompt": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {",
        "outputs": [
            "\n#include <vector>\n#include <array>\n\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256>& bins) {\n    // Initialize the bins to zeros\n    bins.fill(0);\n\n    // Iterate through the image vector\n    for (int intensity : image) {\n        // Increment the count for the corresponding intensity level\n        bins[intensity]++;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "20_histogram_pixel_histogram",
        "parallelism_model": "omp",
        "prompt": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {",
        "outputs": [
            "\n#include <vector>\n#include <array>\n#include <omp.h>\n\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n    // Initialize the bins to zeros\n    #pragma omp parallel for\n    for (int i = 0; i < 256; ++i) {\n        bins[i] = 0;\n    }\n\n    // Count the pixels in the image\n    #pragma omp parallel for\n    for (size_t idx = 0; idx < image.size(); ++idx) {\n        #pragma omp atomic\n        ++bins[image[idx]];\n    }\n}\n\nint main() {\n    std::vector<int> image = {2, 116, 201, 11, 92, 92, 201, 4, 2};\n    std::array<size_t, 256> bins;\n\n    pixelCounts(image, bins);\n\n    // Output the counts\n    for (int i = 0; i < 256; ++i) {\n        std::cout << \"Intensity \" << i << \": \" << bins[i] << \" pixels\" << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "21_histogram_bin_0-100",
        "parallelism_model": "serial",
        "prompt": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <array>\n\nvoid binsBy10Count(const std::vector<double> &x, std::array<size_t, 10> &bins) {\n    for (double value : x) {\n        size_t bin = static_cast<size_t>(value) / 10;\n        if (bin < bins.size()) {\n            ++bins[bin];\n        }\n    }\n}\n\nint main() {\n    std::vector<double> input = {7, 32, 95, 12, 39, 32, 11, 71, 70, 66};\n    std::array<size_t, 10> bins = {0};\n\n    binsBy10Count(input, bins);\n\n    for (size_t i = 0; i < bins.size(); ++i) {\n        std::cout << \"Count in bin [\" << i * 10 << \", \" << (i + 1) * 10 << \"): \" << bins[i] << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "21_histogram_bin_0-100",
        "parallelism_model": "omp",
        "prompt": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <array>\n#include <omp.h>\n\nvoid binsBy10Count(const std::vector<double>& x, std::array<size_t, 10>& bins) {\n    // Initialize bins to zeros\n    bins.fill(0);\n\n    // Use OpenMP to parallelize the computation\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        int bin = x[i] / 10; // Determine the bin index for the value\n        #pragma omp atomic\n        ++bins[bin];\n    }\n}\n\nint main() {\n    std::vector<double> input = {7, 32, 95, 12, 39, 32, 11, 71, 70, 66};\n    std::array<size_t, 10> bins;\n\n    binsBy10Count(input, bins);\n\n    // Output the result\n    for (size_t i = 0; i < bins.size(); ++i) {\n        std::cout << bins[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "22_histogram_count_quadrants",
        "parallelism_model": "serial",
        "prompt": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {",
        "outputs": [
            "\n#include <vector>\n#include <array>\n\nstruct Point {\n    double x, y;\n};\n\nvoid countQuadrants(const std::vector<Point> &points, std::array<size_t, 4> &bins) {\n    // Initialize the bins array with zeros\n    bins.fill(0);\n\n    // Iterate over each point in the vector\n    for(const Point &point : points) {\n        if (point.x > 0 && point.y > 0) {\n            // Point in first quadrant\n            bins[0]++;\n        } else if (point.x < 0 && point.y > 0) {\n            // Point in second quadrant\n            bins[1]++;\n        } else if (point.x < 0 && point.y < 0) {\n            // Point in third quadrant\n            bins[2]++;\n        } else if (point.x > 0 && point.y < 0) {\n            // Point in fourth quadrant\n            bins[3]++;\n        }\n    }\n}\n\nint main() {\n    std::vector<Point> points = {{1.5, 0.1}, {-3, 1.1}, {5, 9}, {1.5, -1}, {3, -7}, {0.1, 2}};\n    std::array<size_t, 4> bins = {0, 0, 0, 0};\n\n    countQuadrants(points, bins);\n\n    // Display the counts in each quadrant\n    for(size_t i = 0; i < bins.size(); ++i) {\n        std::cout << \"Quadrant \" << (i+1) << \" count: \" << bins[i] << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "22_histogram_count_quadrants",
        "parallelism_model": "omp",
        "prompt": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {",
        "outputs": [
            "\n#include <omp.h>\n#include <vector>\n#include <array>\n\nstruct Point {\n    double x, y;\n};\n\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n    bins.fill(0);\n    \n    #pragma omp parallel for\n    for (size_t i = 0; i < points.size(); i++) {\n        Point const& p = points[i];\n        int quadrant = 0;\n\n        if (p.x > 0 && p.y > 0) {\n            quadrant = 0;\n        } else if (p.x < 0 && p.y > 0) {\n            quadrant = 1;\n        } else if (p.x < 0 && p.y < 0) {\n            quadrant = 2;\n        } else if (p.x > 0 && p.y < 0) {\n            quadrant = 3;\n        }\n        \n        #pragma omp atomic\n        bins[quadrant]++;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "23_histogram_first_letter_counts",
        "parallelism_model": "serial",
        "prompt": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <array>\n\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    for (const std::string& str : s) {\n        if (!str.empty()) {\n            char firstChar = str[0];\n            if (firstChar >= 'a' && firstChar <= 'z') {\n                bins[firstChar - 'a']++;\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> input = {\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"};\n    std::array<size_t, 26> bins = {0};\n\n    firstLetterCounts(input, bins);\n\n    // Output the result\n    std::cout << \"[\";\n    for (size_t count : bins) {\n        std::cout << count << \", \";\n    }\n    std::cout << \"]\" << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "23_histogram_first_letter_counts",
        "parallelism_model": "omp",
        "prompt": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <array>\n#include <omp.h>\n\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < 26; ++i) {\n        bins[i] = 0;\n        for (const std::string& str : s) {\n            if (str.front() == 'a' + i) {\n                #pragma omp atomic\n                ++bins[i];\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> input = {\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"};\n    std::array<size_t, 26> output {};\n\n    firstLetterCounts(input, output);\n\n    // Output the result\n    for (size_t i = 0; i < output.size(); ++i) {\n        std::cout << output[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "24_histogram_count_quartile",
        "parallelism_model": "serial",
        "prompt": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {",
        "outputs": [
            "\n#include <vector>\n#include <array>\n#include <cmath>\n\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    for (double num : x) {\n        double frac;\n        double intPart = std::modf(num, &frac);\n        \n        if (frac < 0.25) {\n            ++bins[0];\n        } else if (frac < 0.5) {\n            ++bins[1];\n        } else if (frac < 0.75) {\n            ++bins[2];\n        } else {\n            ++bins[3];\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "24_histogram_count_quartile",
        "parallelism_model": "omp",
        "prompt": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {",
        "outputs": [
            "\n#include <vector>\n#include <array>\n#include <omp.h>\n\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    bins.fill(0); // Initialize bins to 0\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        double val = x[i];\n        double fractionalPart = val - static_cast<int>(val); // Compute fractional part\n\n        if (fractionalPart < 0.25) {\n            #pragma omp atomic\n            ++bins[0];\n        } else if (fractionalPart < 0.5) {\n            #pragma omp atomic\n            ++bins[1];\n        } else if (fractionalPart < 0.75) {\n            #pragma omp atomic\n            ++bins[2];\n        } else {\n            #pragma omp atomic\n            ++bins[3];\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "25_reduce_xor",
        "parallelism_model": "serial",
        "prompt": "/* Return the logical XOR reduction of the vector of bools x.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {",
        "outputs": [
            "\n#include <vector>\n\nbool reduceLogicalXOR(const std::vector<bool>& x) {\n    bool result = false;\n    for (bool b : x) {\n        result ^= b;\n    }\n    return result;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "25_reduce_xor",
        "parallelism_model": "omp",
        "prompt": "/* Return the logical XOR reduction of the vector of bools x.\n   Use OpenMP to reduce in parallel.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n    bool result = false;  // Initialize result assuming all elements are false\n\n    #pragma omp parallel for reduction(^:result)\n    for (size_t i = 0; i < x.size(); ++i) {\n        result ^= x[i];\n    }\n\n    return result;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "26_reduce_product_of_inverses",
        "parallelism_model": "serial",
        "prompt": "/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {",
        "outputs": [
            "\ndouble productWithInverses(std::vector<double> const& x) {\n    double product = 1.0;\n    for (size_t i = 0; i < x.size(); i++) {\n        if (i % 2 == 0) {\n            product *= x[i];\n        } else {\n            product /= x[i];\n        }\n    }\n    return product;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "26_reduce_product_of_inverses",
        "parallelism_model": "omp",
        "prompt": "/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Use OpenMP to compute product in parallel.\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\ndouble productWithInverses(std::vector<double> const& x) {\n    double product = 1.0;\n\n    #pragma omp parallel for reduction(*:product)\n    for (int i = 0; i < x.size(); i++) {\n        if (i % 2 == 0) {\n            product *= x[i];\n        } else {\n            product /= x[i];\n        }\n    }\n\n    return product;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "27_reduce_average",
        "parallelism_model": "serial",
        "prompt": "/* Return the average of the vector x.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n\ndouble average(std::vector<double> const& x) {\n    if (x.empty()) {\n        return 0.0; // Handling the case where the vector is empty\n    }\n\n    double sum = 0.0;\n    for (auto const& elem : x) {\n        sum += elem;\n    }\n\n    return sum / x.size();\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "27_reduce_average",
        "parallelism_model": "omp",
        "prompt": "/* Return the average of the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <numeric>\n#include <omp.h>\n\ndouble average(std::vector<double> const& x) {\n    double sum = 0.0;\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += x[i];\n    }\n\n    return sum / x.size();\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "28_reduce_smallest_odd_number",
        "parallelism_model": "serial",
        "prompt": "/* Return the value of the smallest odd number in the vector x.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {",
        "outputs": [
            "\n#include <vector>\n\nint smallestOdd(std::vector<int> const& x) {\n    int smallestOdd = -1; // Initialize with a value that indicates no odd number found yet\n\n    for (int num : x) {\n        if (num % 2 != 0 && (smallestOdd == -1 || num < smallestOdd)) {\n            smallestOdd = num;\n        }\n    }\n\n    return smallestOdd;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "28_reduce_smallest_odd_number",
        "parallelism_model": "omp",
        "prompt": "/* Return the value of the smallest odd number in the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <omp.h>\n\nint smallestOdd(std::vector<int> const& x) {\n    int smallestOddNum = std::numeric_limits<int>::max();\n\n    #pragma omp parallel for\n    for(size_t i = 0; i < x.size(); ++i) {\n        if(x[i] % 2 != 0 && x[i] < smallestOddNum) {\n            #pragma omp critical\n            {\n                if(x[i] < smallestOddNum) {\n                    smallestOddNum = x[i];\n                }\n            }\n        }\n    }\n    \n    return smallestOddNum;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "29_reduce_sum_of_min_of_pairs",
        "parallelism_model": "serial",
        "prompt": "/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n    double sum = 0.0;\n    size_t size = std::min(x.size(), y.size());\n\n    for (size_t i = 0; i < size; ++i) {\n        sum += std::min(x[i], y[i]);\n    }\n\n    return sum;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "29_reduce_sum_of_min_of_pairs",
        "parallelism_model": "omp",
        "prompt": "/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Use OpenMP to sum in parallel.\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n    size_t size = x.size();\n    double sum = 0.0;\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < size; ++i) {\n        sum += std::min(x[i], y[i]);\n    }\n\n    return sum;\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "30_scan_prefix_sum",
        "parallelism_model": "serial",
        "prompt": "/* Compute the prefix sum of the vector x into output.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {",
        "outputs": [
            "\n#include <vector>\n\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n    if (x.empty()) {\n        return;\n    }\n\n    output.resize(x.size());\n    output[0] = x[0];\n    \n    for (size_t i = 1; i < x.size(); ++i) {\n        output[i] = output[i - 1] + x[i];\n    }\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "30_scan_prefix_sum",
        "parallelism_model": "omp",
        "prompt": "/* Compute the prefix sum of the vector x into output.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n    output.resize(x.size());\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        output[i] = x[i] + (i > 0 ? output[i - 1] : 0);\n    }\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "31_scan_scan_with_min_function",
        "parallelism_model": "serial",
        "prompt": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n\nvoid partialMinimums(std::vector<float> &x) {\n    if (x.empty()) {\n        return; // Nothing to do for an empty vector\n    }\n\n    float min_val = x[0]; // Initialize min_val with the first element\n    for (size_t i = 0; i < x.size(); ++i) {\n        min_val = std::min(min_val, x[i]); // Update min_val with the minimum value found so far\n        x[i] = min_val; // Replace the i-th element with the minimum value found up to the i-th index\n    }\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "31_scan_scan_with_min_function",
        "parallelism_model": "omp",
        "prompt": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {",
        "outputs": [
            "\nvoid partialMinimums(std::vector<float> &x) {\n    // Get the size of the vector\n    int n = x.size();\n\n    // Parallelize the loop\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        float min_val = x[0]; // Initialize minimum value to the first element\n        for (int j = 1; j <= i; j++) {\n            min_val = std::min(min_val, x[j]);\n        }\n        x[i] = min_val; // Update the i-th element with the minimum value from 0 to i\n    }\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "32_scan_sum_of_prefix_sum_array",
        "parallelism_model": "serial",
        "prompt": "/* Compute the prefix sum array of the vector x and return its sum.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n    double sum = 0;\n    double prefixSum = 0;\n\n    for (double num : x) {\n        prefixSum += num;\n        sum += prefixSum;\n    }\n\n    return sum;\n}\n\nint main() {\n    std::vector<double> input = {-7, 2, 1, 9, 4, 8};\n    double result = sumOfPrefixSum(input);\n    std::cout << \"Sum of Prefix Sums: \" << result << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "32_scan_sum_of_prefix_sum_array",
        "parallelism_model": "omp",
        "prompt": "/* Compute the prefix sum array of the vector x and return its sum.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n    int n = x.size();\n    std::vector<double> prefixSum(n);\n    \n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0) + x[i];\n    }\n\n    double sum = 0.0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < n; ++i) {\n        sum += prefixSum[i];\n    }\n\n    return sum;\n}\n\nint main() {\n    std::vector<double> input = {-7, 2, 1, 9, 4, 8};\n    double result = sumOfPrefixSum(input);\n\n    // Output the result\n    std::cout << \"Sum of the prefix sum array: \" << result << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "33_scan_reverse_prefix_sum",
        "parallelism_model": "serial",
        "prompt": "/* Compute the reverse prefix sum of the vector x into output.\n   Examples:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [2, 8, 14, 18, 25, 26]\n\n   input: [3, 3, 7, 1, -2]\n   output: [-2, -1, 6, 9, 12]\n*/\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {",
        "outputs": [
            "\n#include <vector>\n\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    if (x.empty()) {\n        output.clear();\n        return;\n    }\n\n    output.resize(x.size());\n    int sum = 0;\n    \n    for (int i = x.size() - 1; i >= 0; --i) {\n        sum += x[i];\n        output[i] = sum;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "33_scan_reverse_prefix_sum",
        "parallelism_model": "omp",
        "prompt": "/* Compute the reverse prefix sum of the vector x into output.\n   Use OpenMP to compute in parallel.\n   Examples:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [2, 8, 14, 18, 25, 26]\n\n   input: [3, 3, 7, 1, -2]\n   output: [-2, -1, 6, 9, 12]\n*/\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    int size = x.size();\n    output.resize(size);\n\n    // Compute the reverse prefix sum in parallel using OpenMP\n    #pragma omp parallel for\n    for (int i = size - 1; i >= 0; i--) {\n        if (i == size - 1) {\n            output[i] = x[i];\n        } else {\n            output[i] = output[i + 1] + x[i];\n        }\n    }\n}\n\n// You can use this function to test the reverse prefix sum computation\nvoid testReversePrefixSum() {\n    std::vector<int> input1 = {1, 7, 4, 6, 6, 2};\n    std::vector<int> input2 = {3, 3, 7, 1, -2};\n    std::vector<int> output1, output2;\n\n    reversePrefixSum(input1, output1);\n    reversePrefixSum(input2, output2);\n\n    // Display the results\n    for (int num : output1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    for (int num : output2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    testReversePrefixSum();\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "34_scan_largest_contiguous_subarray_sum",
        "parallelism_model": "serial",
        "prompt": "/* Return the largest sum of any contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4] then [4, \u22121, 2, 1] is the contiguous\n   subarray with the largest sum of 6.\n   Example:\n\n   input: [\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4]\n   output: 6\n*/\nint maximumSubarray(std::vector<int> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm> // for std::max\n\nint maximumSubarray(std::vector<int> const& x) {\n    int max_sum = x[0];\n    int current_sum = x[0];\n\n    for (size_t i = 1; i < x.size(); ++i) {\n        current_sum = std::max(x[i], current_sum + x[i]);\n        max_sum = std::max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n\n// Example usage:\nint main() {\n    std::vector<int> x = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    int result = maximumSubarray(x);\n    // Output the result\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "34_scan_largest_contiguous_subarray_sum",
        "parallelism_model": "omp",
        "prompt": "/* Return the largest sum of any contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4] then [4, \u22121, 2, 1] is the contiguous\n   subarray with the largest sum of 6.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4]\n   output: 6\n*/\nint maximumSubarray(std::vector<int> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <iostream>\n#include <omp.h>\n\nint maximumSubarray(std::vector<int> const& x) {\n    int max_ending_here = x[0];\n    int max_so_far = x[0];\n\n    #pragma omp parallel for\n    for (int i = 1; i < x.size(); ++i) {\n        max_ending_here = std::max(x[i], max_ending_here + x[i]);\n        max_so_far = std::max(max_so_far, max_ending_here);\n    }\n\n    return max_so_far;\n}\n\nint main() {\n    std::vector<int> x = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    int result = maximumSubarray(x);\n    std::cout << \"Maximum sum of contiguous subarray: \" << result << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "35_search_search_for_last_struct_by_key",
        "parallelism_model": "serial",
        "prompt": "struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",
        "outputs": [
            "\n#include <vector>\n#include <string>\n\nstruct Book {\n    std::string title;\n    int pages;\n};\n\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    for (size_t i = books.size(); i > 0; --i) {\n        if (books[i - 1].pages < 100) {\n            return i - 1;\n        }\n    }\n    // If no book with pages < 100 is found, return an appropriate value (e.g., books.size()).\n    return books.size();\n}\n\nint main() {\n    std::vector<Book> books = {\n        {\"Green Eggs and Ham\", 72},\n        {\"gulliver's travels\", 362},\n        {\"Stories of Your Life\", 54},\n        {\"Hamilton\", 818}\n    };\n\n    size_t index = findLastShortBook(books);\n    if (index < books.size()) {\n        std::cout << \"Index of the last book with pages < 100: \" << index << std::endl;\n    } else {\n        std::cout << \"No book with pages < 100 found in the provided list.\" << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "35_search_search_for_last_struct_by_key",
        "parallelism_model": "omp",
        "prompt": "struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",
        "outputs": [
            "\n#include <omp.h>\n#include <vector>\n#include <string>\n\nstruct Book {\n    std::string title;\n    int pages;\n};\n\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    // Initialize a variable to store the index of the last short book\n    size_t lastShortBookIndex = 0;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].pages < 100) {\n            // Critical section to update the lastShortBookIndex\n            #pragma omp critical\n            {\n                lastShortBookIndex = i;\n            }\n        }\n    }\n\n    return lastShortBookIndex;\n}\n\nint main() {\n    std::vector<Book> books = {\n        {\"Green Eggs and Ham\", 72},\n        {\"gulliver's travels\", 362},\n        {\"Stories of Your Life\", 54},\n        {\"Hamilton\", 818}\n    };\n\n    size_t lastShortBookIndex = findLastShortBook(books);\n    \n    // Output the index of the last short book\n    std::cout << \"Index of the last short book: \" << lastShortBookIndex << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "36_search_check_if_array_contains_value",
        "parallelism_model": "serial",
        "prompt": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",
        "outputs": [
            "\n#include <vector>\n\nbool contains(std::vector<int> const& x, int target) {\n    for (int value : x) {\n        if (value == target) {\n            return true;\n        }\n    }\n    return false;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "36_search_check_if_array_contains_value",
        "parallelism_model": "omp",
        "prompt": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nbool contains(std::vector<int> const& x, int target) {\n    bool result = false;\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            #pragma omp critical\n            {\n                result = true;\n            }\n        }\n    }\n\n    return result;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "37_search_find_the_closest_number_to_pi",
        "parallelism_model": "serial",
        "prompt": "/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <cmath>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    double closestDiff = std::abs(x[0] - M_PI);\n    size_t closestIndex = 0;\n\n    for (size_t i = 1; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < closestDiff) {\n            closestDiff = diff;\n            closestIndex = i;\n        }\n    }\n\n    return closestIndex;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "37_search_find_the_closest_number_to_pi",
        "parallelism_model": "omp",
        "prompt": "/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <cmath>\n#include <omp.h>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    // Initialize variables for minimum difference and index\n    double minDiff = std::abs(M_PI - x[0]);\n    size_t index = 0;\n\n    // Use OpenMP to parallelize the search for the closest value to PI\n#pragma omp parallel for\n    for (size_t i = 1; i < x.size(); ++i) {\n        double diff = std::abs(M_PI - x[i]);\n        if (diff < minDiff) {\n            // Update the minimum difference and index if a closer value is found\n#pragma omp critical\n            {\n                if (diff < minDiff) {\n                    minDiff = diff;\n                    index = i;\n                }\n            }\n        }\n    }\n\n    return index;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "38_search_find_the_first_even_number",
        "parallelism_model": "serial",
        "prompt": "/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",
        "outputs": [
            "\n#include <vector>\n\nsize_t findFirstEven(std::vector<int> const& x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) { // Check if current element is even\n            return i; // Return the index if found\n        }\n    }\n    return -1; // Return -1 if no even number is found\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "38_search_find_the_first_even_number",
        "parallelism_model": "omp",
        "prompt": "/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nsize_t findFirstEven(std::vector<int> const& x) {\n    size_t index = x.size();\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < index) {\n                    index = i;\n                }\n            }\n        }\n    }\n\n    return index;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "39_search_xor_contains",
        "parallelism_model": "serial",
        "prompt": "/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",
        "outputs": [
            "\n#include <vector>\n#include <unordered_set>\n\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool inX = std::find(x.begin(), x.end(), val) != x.end();\n    bool inY = std::find(y.begin(), y.end(), val) != y.end();\n\n    // Return true if val is only in one of the vectors x or y\n    // Return false if it is in both or neither\n    return (inX && !inY) || (!inX && inY);\n}\n\n// Test your function with the provided examples\nint main() {\n    std::vector<int> x = {1, 8, 4, 3, 2};\n    std::vector<int> y = {3, 4, 4, 1, 1, 7};\n\n    // Test case 1\n    int val1 = 7;\n    bool result1 = xorContains(x, y, val1);\n    std::cout << \"Is \" << val1 << \" found in only one vector? \" << std::boolalpha << result1 << std::endl;\n\n    // Test case 2\n    int val2 = 1;\n    bool result2 = xorContains(x, y, val2);\n    std::cout << \"Is \" << val2 << \" found in only one vector? \" << std::boolalpha << result2 << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "39_search_xor_contains",
        "parallelism_model": "omp",
        "prompt": "/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",
        "outputs": [
            "\n#include <vector>\n#include <iostream>\n#include <omp.h>\n\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool foundInX = false;\n    bool foundInY = false;\n\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] == val) {\n            #pragma omp atomic write\n            foundInX = true;\n        }\n    }\n\n#pragma omp parallel for\n    for (size_t i = 0; i < y.size(); ++i) {\n        if (y[i] == val) {\n            #pragma omp atomic write\n            foundInY = true;\n        }\n    }\n    \n    if ((foundInX && !foundInY) || (!foundInX && foundInY)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    std::vector<int> x = {1, 8, 4, 3, 2};\n    std::vector<int> y = {3, 4, 4, 1, 1, 7};\n    int val = 7;\n    \n    bool result = xorContains(x, y, val);\n    \n    if (result) {\n        std::cout << \"true\\n\";\n    } else {\n        std::cout << \"false\\n\";\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "40_sort_sort_an_array_of_complex_numbers_by_magnitude",
        "parallelism_model": "serial",
        "prompt": "/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nbool compareMagnitude(const std::complex<double> &a, const std::complex<double> &b) {\n    return std::abs(a) < std::abs(b);\n}\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    std::sort(x.begin(), x.end(), compareMagnitude);\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "40_sort_sort_an_array_of_complex_numbers_by_magnitude",
        "parallelism_model": "omp",
        "prompt": "/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <omp.h>\n\nbool compareByMagnitude(const std::complex<double> &a, const std::complex<double> &b) {\n    return std::abs(a) < std::abs(b);\n}\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    // Sort the vector x by magnitude in parallel using OpenMP\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        x[i] = std::complex<double>(std::abs(x[i]), 0.0);\n    }\n\n    std::sort(x.begin(), x.end(), compareByMagnitude);\n}\n\nint main() {\n    // Example input\n    std::vector<std::complex<double>> input = { {3.0, -1.0}, {4.5, 2.1}, {0.0, -1.0}, {1.0, 0.0}, {0.5, 0.5} };\n\n    sortComplexByMagnitude(input);\n\n    // Output the sorted vector\n    for (const auto &num : input) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "41_sort_k-th_smallest_element",
        "parallelism_model": "serial",
        "prompt": "/* Find the k-th smallest element of the vector x.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n\nint findKthSmallest(std::vector<int> const& x, int k) {\n    std::vector<int> sortedX = x;\n    std::sort(sortedX.begin(), sortedX.end());\n\n    // Return the k-th smallest element (k-1 index in zero-based indexing)\n    return sortedX[k - 1];\n}\n\n// Example usage\n// int main() {\n//     std::vector<int> x = {1, 7, 6, 0, 2, 2, 10, 6};\n//     int k = 4;\n//     int result = findKthSmallest(x, k);\n//     // Output should be 6\n//     return 0;\n// }\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "41_sort_k-th_smallest_element",
        "parallelism_model": "omp",
        "prompt": "/* Find the k-th smallest element of the vector x.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nint findKthSmallest(std::vector<int> const& x, int k) {\n    int result = 0;\n\n    #pragma omp parallel\n    {\n        std::vector<int> localX(x);\n\n        #pragma omp single\n        {\n            std::sort(localX.begin(), localX.end());\n        }\n\n        #pragma omp single\n        {\n            result = localX[k - 1];\n        }\n    }\n\n    return result;\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "42_sort_sorted_ranks",
        "parallelism_model": "serial",
        "prompt": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {",
        "outputs": [
            "\n#include <vector>\n#include <map>\n#include <algorithm>\n\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n    // Create a copy of the original vector and sort it in increasing order\n    std::vector<float> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n\n    // Initialize a map to store index of each element in the sorted vector\n    std::map<float, size_t> index_map;\n    for (size_t i = 0; i < sorted_x.size(); ++i) {\n        index_map[sorted_x[i]] = i;\n    }\n\n    // Get ranks for elements in the original vector\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks.push_back(index_map[x[i]]);\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "42_sort_sorted_ranks",
        "parallelism_model": "omp",
        "prompt": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n    // Create a temporary vector to store the sorted indices\n    std::vector<size_t> temp(x.size());\n\n    // Initialize ranks vector to be the same size as x\n    ranks.resize(x.size());\n\n    // Create a vector of indices [0, 1, 2, ..., x.size()-1]\n    std::iota(temp.begin(), temp.end(), 0);\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        // Sort indices based on the values in x\n        std::sort(temp.begin(), temp.end(), [&x](size_t a, size_t b) {\n            return x[a] < x[b];\n        });\n\n        // Find the rank of the current element in the sorted array\n        size_t rank = 0;\n        while (temp[rank] != i) {\n            ++rank;\n        }\n\n        // Store the rank in the ranks vector\n        ranks[i] = rank;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "43_sort_sort_an_array_of_structs_by_key",
        "parallelism_model": "serial",
        "prompt": "struct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n\nstruct Result {\n    int startTime, duration;\n    float value;\n};\n\nbool compareByStartTime(const Result& a, const Result& b) {\n    return a.startTime < b.startTime;\n}\n\nvoid sortByStartTime(std::vector<Result> &results) {\n    std::sort(results.begin(), results.end(), compareByStartTime);\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "43_sort_sort_an_array_of_structs_by_key",
        "parallelism_model": "omp",
        "prompt": "struct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\nbool compareByStartTime(const Result &a, const Result &b) {\n    return a.startTime < b.startTime;\n}\n\nvoid sortByStartTime(std::vector<Result> &results) {\n    #pragma omp parallel for\n    for (int i = 0; i < results.size(); ++i) {\n        #pragma omp for\n        for (int j = i + 1; j < results.size(); ++j) {\n            if (results[i].startTime > results[j].startTime) {\n                std::swap(results[i], results[j]);\n            }\n        }\n    }\n\n    // Alternatively, you can use the STL sort function for better performance\n    // std::sort(results.begin(), results.end(), compareByStartTime);\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "44_sort_sort_non-zero_elements",
        "parallelism_model": "serial",
        "prompt": "/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place.\n   Example:\n\n\t input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n\nvoid sortIgnoreZero(std::vector<int> &x) {\n    std::vector<int> nonZeroElements;\n    std::vector<int> zeroIndices;\n\n    // Separate non-zero elements and zero indices\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            nonZeroElements.push_back(x[i]);\n        } else {\n            zeroIndices.push_back(i);\n        }\n    }\n\n    // Sort non-zero elements\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n\n    // Place sorted non-zero elements back into the vector\n    size_t nonZeroIndex = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (std::find(zeroIndices.begin(), zeroIndices.end(), i) == zeroIndices.end()) {\n            x[i] = nonZeroElements[nonZeroIndex];\n            ++nonZeroIndex;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "44_sort_sort_non-zero_elements",
        "parallelism_model": "omp",
        "prompt": "/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place. \n\t Use OpenMP to sort x in parallel. \n   Example:\n\n   input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nvoid sortIgnoreZero(std::vector<int> &x) {\n    std::vector<int> nonZeroElements;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            #pragma omp critical\n            nonZeroElements.push_back(x[i]);\n        }\n    }\n\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n\n    size_t j = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            x[i] = nonZeroElements[j++];\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "45_sparse_la_sparse_solve",
        "parallelism_model": "serial",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Solve the sparse linear system Ax=b for x.\n   A is a sparse NxN matrix in COO format. x and b are dense vectors with N elements.\n   Example:\n   \n   input: A=[{0,0,1}, {0,1,1}, {1,1,-2}] b=[1,4]\n   output: x=[3,-2]\n*/\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <iostream>\n#include <cstddef>\n#include <Eigen/Sparse>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double>& x, size_t N) {\n    // Build a sparse matrix from COO format\n    Eigen::SparseMatrix<double> sparseA(N, N);\n    std::vector<Eigen::Triplet<double>> tripletList;\n    tripletList.reserve(A.size());\n    for (const auto& element : A) {\n        tripletList.emplace_back(element.row, element.column, element.value);\n    }\n    sparseA.setFromTriplets(tripletList.begin(), tripletList.end());\n\n    // Solve the linear system Ax=b\n    Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;\n    solver.compute(sparseA);\n\n    if (solver.info() != Eigen::Success) {\n        std::cerr << \"Error during decomposition of the sparse matrix.\" << std::endl;\n        return;\n    }\n\n    Eigen::Map<Eigen::VectorXd> bVec(b.data(), N);\n    Eigen::Map<Eigen::VectorXd> xVec(x.data(), N);\n    xVec = solver.solve(bVec);\n\n    std::cout << \"Solution x: \" << xVec.transpose() << std::endl;\n}\n\nint main() {\n    // Example COO format input {0,0,1}, {0,1,1}, {1,1,-2}\n    std::vector<COOElement> A = {{0, 0, 1}, {0, 1, 1}, {1, 1, -2}};\n    std::vector<double> b = {1, 4};\n\n    size_t N = 2; // Size of the square matrix A\n    std::vector<double> x(N);\n\n    solveLinearSystem(A, b, x, N);\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "45_sparse_la_sparse_solve",
        "parallelism_model": "omp",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Solve the sparse linear system Ax=b for x.\n   A is a sparse NxN matrix in COO format. x and b are dense vectors with N elements.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: A=[{0,0,1}, {0,1,1}, {1,1,-2}] b=[1,4]\n   output: x=[3,-2]\n*/\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    // Convert COO to CSR\n    std::vector<size_t> row_ptr(N+1, 0);\n    std::vector<size_t> col_idx;\n    std::vector<double> values;\n    for (const COOElement& elem : A) {\n        col_idx.push_back(elem.column);\n        values.push_back(elem.value);\n        row_ptr[elem.row + 1]++;\n    }\n    for (size_t i = 1; i <= N; ++i) {\n        row_ptr[i] += row_ptr[i - 1];\n    }\n\n    // Initialize x with zeros\n    x.assign(N, 0.0);\n\n    // Solve Ax = b using OpenMP parallelization\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        double sum = 0.0;\n        for (size_t j = row_ptr[i]; j < row_ptr[i + 1]; ++j) {\n            sum += values[j] * x[col_idx[j]];\n        }\n        x[i] = sum;\n    }\n\n    // Back substitution (if needed)\n}\n\nint main() {\n    size_t N = 2;\n    std::vector<COOElement> A = {{0, 0, 1.0}, {0, 1, 1.0}, {1, 1, -2.0}};\n    std::vector<double> b = {1.0, 4.0};\n    std::vector<double> x(N);\n\n    solveLinearSystem(A, b, x, N);\n\n    // Print the result vector x\n    for (size_t i = 0; i < N; ++i) {\n        std::cout << \"x[\" << i << \"] = \" << x[i] << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "46_sparse_la_spmm",
        "parallelism_model": "serial",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {",
        "outputs": [
            "\n#include <vector>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n    // Initialize the output matrix Y with zeros\n    Y.resize(M * N, 0.0);\n\n    // Perform matrix multiplication\n    for (const auto& elemA : A) {\n        for (const auto& elemX : X) {\n            if (elemA.column == elemX.row) {\n                Y[elemA.row * N + elemX.column] += elemA.value * elemX.value;\n            }\n        }\n    }\n}\n\nint main() {\n    // Example input matrices A and X\n    std::vector<COOElement> A = {{0, 0, -2}, {0, 1, 1}, {1, 1, -1}};\n    std::vector<COOElement> X = {{0, 1, 2}, {1, 0, -1}};\n    \n    // Define the dimensions of the matrices\n    size_t M = 2; // Rows of A, Rows of Y\n    size_t K = 2; // Columns of A, Rows of X\n    size_t N = 2; // Columns of X, Columns of Y\n\n    // Initialize the output matrix Y\n    std::vector<double> Y;\n    \n    // Perform matrix multiplication\n    spmm(A, X, Y, M, K, N);\n\n    // Output the result matrix Y\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            std::cout << Y[i * N + j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "46_sparse_la_spmm",
        "parallelism_model": "omp",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <iostream>\n#include <omp.h>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n    // Step 1: Initialize the output matrix Y\n    #pragma omp parallel for\n    for (size_t i = 0; i < M * N; ++i) {\n        Y[i] = 0.0;\n    }\n\n    // Step 2: Compute matrix product Y=AX\n    #pragma omp parallel for\n    for (size_t i = 0; i < A.size(); ++i) {\n        size_t rowA = A[i].row;\n        size_t colA = A[i].column;\n        double valA = A[i].value;\n\n        for (size_t j = 0; j < X.size(); ++j) {\n            size_t colX = X[j].column;\n            double valX = X[j].value;\n\n            if (colA == colX) {\n                size_t rowY = rowA;\n                size_t colY = X[j].row;\n                Y[rowY * N + colY] += valA * valX;\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<COOElement> A = {{0, 0, -2}, {0, 1, 1}, {1, 1, -1}};\n    std::vector<COOElement> X = {{0, 1, 2}, {1, 0, -1}};\n    size_t M = 2, K = 2, N = 2;\n    std::vector<double> Y(M * N, 0.0);\n\n    spmm(A, X, Y, M, K, N);\n\n    // Output the result matrix Y\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            std::cout << Y[i * N + j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "47_sparse_la_spmv",
        "parallelism_model": "serial",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {",
        "outputs": [
            "function performs the Sparse Matrix-Vector Multiplication (SPMV) operation. It computes y = alpha*A*x + beta*y, where A is a sparse matrix in the Coordinate List (COO) format, alpha and beta are scalars, x and y are vectors.\n\nThe function takes the following parameters:\n- `alpha`: Scalar multiplier for the matrix-vector product.\n- `A`: Vector of COOElement representing the sparse matrix A.\n- `x`: Vector representing the input vector x.\n- `beta`: Scalar multiplier for the vector y.\n- `y`: Vector representing the output vector y. It is also the initial value of y that incorporates the existing values.\n- `M`: Number of rows in the matrix A.\n- `N`: Number of columns in the matrix A.\n\nThe function implementation would involve iterating over the COO format sparse matrix elements, computing the matrix-vector product, and applying alpha and beta as specified. The result will be stored in the output vector y.\n\nHere's a basic outline of the implementation:\n1. Initialize all elements in the output vector y with beta*y.\n2. Iterate over the sparse matrix elements in COO format.\n3. For each element in A, calculate the corresponding product and add it to the respective element in y.\n4. Modify the elements in y with the appropriate scalar multipliers alpha and beta.\n\nIf you have any specific questions or need further clarification on any part of the implementation, feel free to ask"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "47_sparse_la_spmv",
        "parallelism_model": "omp",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use OpenMP to parallelize.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {",
        "outputs": [
            "\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < A.size(); ++j) {\n            if (A[j].row == i) {\n                sum += A[j].value * x[A[j].column];\n            }\n        }\n        y[i] = alpha * sum + beta * y[i];\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "48_sparse_la_sparse_axpy",
        "parallelism_model": "serial",
        "prompt": "struct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {",
        "outputs": [
            "\n#include <vector>\n#include <cmath>\n\nstruct Element {\n    size_t index;\n    double value;\n};\n\nvoid sparseAxpy(double alpha, const std::vector<Element>& x, const std::vector<Element>& y, std::vector<double>& z) {\n    // Initialize the result vector z with the same size as the longer of x and y\n    size_t zSize = std::max(x.size(), y.size());\n    z.resize(zSize);\n\n    // Perform the operation z = alpha*x + y\n    for (const Element& elem : x) {\n        z[elem.index] += alpha * elem.value;\n    }\n\n    for (const Element& elem : y) {\n        z[elem.index] += elem.value;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "48_sparse_la_sparse_axpy",
        "parallelism_model": "omp",
        "prompt": "struct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nstruct Element {\n    size_t index;\n    double value;\n};\n\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double>& z) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        z[x[i].index] = alpha * x[i].value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < y.size(); ++i) {\n        z[y[i].index] += y[i].value;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "49_sparse_la_sparse_lu_decomp",
        "parallelism_model": "serial",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {",
        "outputs": [
            "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid assembleLU(const std::vector<COOElement> &A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n    L.resize(A.size());\n    U.resize(A.size());\n\n    // Initialize L to identity matrix and U to zeros\n    for (size_t i = 0; i < A.size(); ++i) {\n        if (A[i].row == A[i].column) {\n            L[i] = 1.0;\n            U[i] = A[i].value;\n        } else {\n            L[i] = 0.0;\n            U[i] = 0.0;\n        }\n    }\n\n    // Apply LU decomposition algorithm\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t i = 0; i < A.size(); ++i) {\n            if (A[i].row > k) {\n                continue; // Skip entries above the diagonal\n            }\n\n            if (A[i].column == k) {\n                L[i] = A[i].value / U[k * N + k];\n            } else if (A[i].row == k) {\n                U[i] = A[i].value;\n            } else if (A[i].row < k && A[i].column > k) {\n                U[i] -= L[A[i].row * N + k] * U[k * N + A[i].column];\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<COOElement> A = {{0, 0, 4}, {0, 1, 3}, {1, 0, 6}, {1, 1, 3}};\n    size_t N = 2; // Assuming N = 2 for the given example\n\n    std::vector<double> L, U;\n    assembleLU(A, L, U, N);\n\n    // Output the factorized matrices L and U\n    std::cout << \"L:\\n\";\n    for (const auto &elem : L) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"U:\\n\";\n    for (const auto &elem : U) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "49_sparse_la_sparse_lu_decomp",
        "parallelism_model": "omp",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {",
        "outputs": [
            "\n#include <omp.h>\n#include <vector>\n\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n    // Initialize L and U matrices\n    L.clear(); L.resize(N * N, 0.0);\n    U.clear(); U.resize(N * N, 0.0);\n\n    // Set the main diagonal of L to 1\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        L[i * N + i] = 1.0;\n    }\n\n    // Copy elements from A to U\n    #pragma omp parallel for\n    for (size_t i = 0; i < A.size(); ++i) {\n        U[A[i].row * N + A[i].column] = A[i].value;\n    }\n\n    // Perform LU factorization\n    #pragma omp parallel for\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t j = k+1; j < N; ++j) {\n            L[j * N + k] = U[j * N + k] / U[k * N + k];\n            for (size_t i = k; i < N; ++i) {\n                U[j * N + i] -= L[j * N + k] * U[k * N + i];\n            }\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "50_stencil_xor_kernel",
        "parallelism_model": "serial",
        "prompt": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "outputs": [
            "\n#include <vector>\n\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n\n            if (i > 0 && input[(i - 1) * N + j] == 1) count++; // Check top neighbor\n            if (i < N - 1 && input[(i + 1) * N + j] == 1) count++; // Check bottom neighbor\n            if (j > 0 && input[i * N + (j - 1)] == 1) count++; // Check left neighbor\n            if (j < N - 1 && input[i * N + (j + 1)] == 1) count++; // Check right neighbor\n\n            output[i * N + j] = (count == 1) ? 1 : 0;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "50_stencil_xor_kernel",
        "parallelism_model": "omp",
        "prompt": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    #pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int neighbors = 0;\n\n            // Check neighbors on all sides (top, bottom, left, right)\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1; ++dy) {\n                    if (dx == 0 && dy == 0) continue; // Skip the cell itself\n                    int ni = i + dx;\n                    int nj = j + dy;\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N && input[ni * N + nj] == 1) {\n                        neighbors++;\n                    }\n                }\n            }\n\n            if (neighbors == 1) {\n                output[i * N + j] = 1;\n            } else {\n                output[i * N + j] = 0;\n            }\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "51_stencil_edge_kernel",
        "parallelism_model": "serial",
        "prompt": "const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    // Helper function to get pixel value at row x, column y in the 1D image vector\n    auto getPixel = [&](int x, int y) -> int {\n        if (x >= 0 && x < N && y >= 0 && y < N) {\n            return imageIn[x * N + y];\n        }\n        return 0;  // Return 0 for pixels outside boundary\n    };\n\n    // Apply edge kernel convolution\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int pixel = getPixel(i + k, j + l);\n                    sum += pixel * edgeKernel[k + 1][l + 1];\n                }\n            }\n            imageOut[i * N + j] = std::max(0, std::min(255, sum)); // Clip the output\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "51_stencil_edge_kernel",
        "parallelism_model": "omp",
        "prompt": "const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    #pragma omp parallel for\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; losh<= 1; ++l) {\n                    int iIndex = std::max(0, std::min(N - 1, i + k));\n                    int jIndex = std::max(0, std::min(N - 1, j + l));\n                    sum += edgeKernel[k + 1][l + 1] * imageIn[iIndex * N + jultIndex];\n                }\n            }\n            sum = std::min(std::max(sum, 0), 255);\n            imageOut[i * N + j] = sum;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "52_stencil_1d_jacobi_3-point_stencil",
        "parallelism_model": "serial",
        "prompt": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {",
        "outputs": [
            "\n#include <vector>\n\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    int n = input.size();\n\n    // Compute first element\n    output[0] = (n > 1) ? (input[0] + input[1]) / 3.0 : 0.0;\n\n    // Compute middle elements\n    for (int i = 1; i < n - 1; ++i) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3.0;\n    }\n\n    // Compute last element\n    output[n - 1] = (n > 1) ? (input[n - 2] + input[n - 1]) / 3.0 : 0.0;\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "52_stencil_1d_jacobi_3-point_stencil",
        "parallelism_model": "omp",
        "prompt": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    int n = input.size();\n\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        double left = i > 0 ? input[i - 1] : 0;\n        double right = i < n - 1 ? input[i + 1] : 0;\n        output[i] = (left + input[i] + right) / 3.0;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "53_stencil_2d_jacobi_5-point_stencil",
        "parallelism_model": "serial",
        "prompt": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {",
        "outputs": [
            "\n#include <vector>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    // Loop over the 2D grid\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            // Calculate the indices for neighbor elements\n            size_t left = (j == 0) ? 0 : i*N + (j-1);\n            size_t right = (j == N-1) ? 0 : i*N + (j+1);\n            size_t up = (i == 0) ? 0 : (i-1)*N + j;\n            size_t down = (i == N-1) ? 0 : (i+1)*N + j;\n\n            // Compute the Jacobi value of the current element\n            output[i*N + j] = (input[left] + input[right] + input[up] + input[down] + input[i*N + j]) / 5.0;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "53_stencil_2d_jacobi_5-point_stencil",
        "parallelism_model": "omp",
        "prompt": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    #pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            double current_sum = input[i * N + j];\n            double neighbor_sum = 0.0;\n            int count = 1;\n\n            // Neighbor to the left\n            if (j > 0) {\n                neighbor_sum += input[i * N + (j - 1)];\n                count++;\n            }\n\n            // Neighbor to the right\n            if (j < N - 1) {\n                neighbor_sum += input[i * N + (j + 1)];\n                count++;\n            }\n\n            // Neighbor above\n            if (i > 0) {\n                neighbor_sum += input[(i - 1) * N + j];\n                count++;\n            }\n\n            // Neighbor below\n            if (i < N - 1) {\n                neighbor_sum += input[(i + 1) * N + j];\n                count++;\n            }\n\n            output[i * N + j] = (current_sum + neighbor_sum) / count;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "54_stencil_game_of_life",
        "parallelism_model": "serial",
        "prompt": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "outputs": [
            "\n#include <vector>\n\nvoid gameOfLife(std::vector<int> const& input, std::vector<int>& output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int liveNeighbors = 0;\n            // Check all 8 neighbors around the current cell\n            for (int di = -1; di <= 1; ++di) {\n                for (int dj = -1; dj <= 1; ++dj) {\n                    if (di == 0 && dj == 0) continue; // Skip the current cell\n                    int ni = i + di;\n                    int nj = j + dj;\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        liveNeighbors += input[ni * N + nj];\n                    }\n                }\n            }\n\n            // Apply the rules of the Game of Life\n            if (input[i * N + j] == 1) {\n                if (liveNeighbors < 2 || liveNeighbors > 3) {\n                    output[i * N + j] = 0; // Cell dies\n                } else {\n                    output[i * N + j] = 1; // Cell lives on\n                }\n            } else {\n                if (liveNeighbors == 3) {\n                    output[i * N + j] = 1; // Cell becomes alive\n                } else {\n                    output[i * N + j] = 0; // Cell remains dead\n                }\n            }\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "54_stencil_game_of_life",
        "parallelism_model": "omp",
        "prompt": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "outputs": [
            "\n    #pragma omp parallel for collapse(2)  // Use OpenMP for parallel computation\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int liveNeighbors = 0;\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1; ++dy) {\n                    if (dx == 0 && dy == 0) continue;  // Skip the current cell\n                    int newX = i + dx;\n                    int newY = j + dy;\n                    if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                        liveNeighbors += input[newX * N + newY];\n                    }\n                }\n            }\n\n            if (input[i * N + j] == 1) {  // Current cell is alive\n                if (liveNeighbors < 2 || liveNeighbors > 3) {\n                    output[i * N + j] = 0;  // Cell dies\n                } else {\n                    output[i * N + j] = 1;  // Cell lives on\n                }\n            } else {  // Current cell is dead\n                if (liveNeighbors == 3) {\n                    output[i * N + j] = 1;  // Cell becomes alive\n                } else {\n                    output[i * N + j] = 0;  // Cell remains dead\n                }\n            }\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "55_transform_relu",
        "parallelism_model": "serial",
        "prompt": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {",
        "outputs": [
            "\n#include <vector>\n\nvoid relu(std::vector<double> &x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] < 0) {\n            x[i] = 0;  // Setting negative values to zero\n        }\n        // Non-negative values stay the same\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "55_transform_relu",
        "parallelism_model": "omp",
        "prompt": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid relu(std::vector<double> &x) {\n    // Specify that we want to parallelize the for loop\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        // Apply ReLU function\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "56_transform_negate_odds",
        "parallelism_model": "serial",
        "prompt": "/* In the vector x negate the odd values and divide the even values by 2.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {",
        "outputs": [
            "\n#include <vector>\n\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    for (int &num : x) {\n        if (num % 2 == 0) {\n            num /= 2;  // divide even numbers by 2\n        } else {\n            num = -num;  // negate odd numbers\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "56_transform_negate_odds",
        "parallelism_model": "omp",
        "prompt": "/* In the vector x negate the odd values and divide the even values by 2.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "57_transform_inverse_offset",
        "parallelism_model": "serial",
        "prompt": "/* Replace every element of the vector x with 1-1/x.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {",
        "outputs": [
            "\n#include <vector>\n\nvoid oneMinusInverse(std::vector<double> &x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            x[i] = 1.0 - 1.0 / x[i];\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "57_transform_inverse_offset",
        "parallelism_model": "omp",
        "prompt": "/* Replace every element of the vector x with 1-1/x.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid oneMinusInverse(std::vector<double> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        x[i] = 1.0 - 1.0 / x[i];\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "58_transform_squaring",
        "parallelism_model": "serial",
        "prompt": "/* Replace every element of x with the square of its value.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {",
        "outputs": [
            "\n#include <vector>\n\nvoid squareEach(std::vector<int> &x) {\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i]; // Square each element\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "58_transform_squaring",
        "parallelism_model": "omp",
        "prompt": "/* Replace every element of x with the square of its value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {",
        "outputs": [
            "\n#include <vector>\n#include <omp.h>\n\nvoid squareEach(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "59_transform_map_function",
        "parallelism_model": "serial",
        "prompt": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {",
        "outputs": [
            "\n#include <vector>\n\nbool isPowerOfTwo(int x) {\n    return (x > 0) && !(x & (x - 1));\n}\n\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    mask.clear();  // Clear the mask vector before populating it\n    mask.reserve(x.size());  // Reserve space for the elements\n\n    for (int num : x) {\n        mask.push_back(isPowerOfTwo(num));\n    }\n}\n\nint main() {\n    std::vector<int> input = {8, 0, 9, 7, 15, 64, 3};\n    std::vector<bool> output;\n\n    mapPowersOfTwo(input, output);\n\n    // Output the results\n    for (size_t i = 0; i < input.size(); ++i) {\n        std::cout << \"Input: \" << input[i] << \", Output: \" << (output[i] ? \"true\" : \"false\") << std::endl;\n    }\n\n    return 0;\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "59_transform_map_function",
        "parallelism_model": "omp",
        "prompt": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {",
        "outputs": [
            "\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        mask[i] = isPowerOfTwo(x[i]);\n    }\n}\n"
        ]
    }
]